---
layout: post
title: Algorithm Part 4
---

## 朴素的算法思想

这一篇我们来继续聊一聊一些经典的计算机算法，包括：二分查找，贪心，动态规划，深搜，广搜等

### 二分查找

- 前提：有序序列
- 方法：折半查找

```
left = 0, right = n-1
while( left <= right ){
	mid = (left+right)/2
	if(x[mid] < t){
		left = mid + 1;
	}else if(x[mid] == t){
		p = mid;
		break;
	}eles{
		right = mid-1;
	}
}
```

### 贪心法

- 求最优化解问题
	- 问题求解时, 总是做出在当前看来是最好的选择，不保证全局最优
		- 旅行推销员问题，每次选择最近城市
		- 换零钱问题，每次拿面值最大的
		- 图的最小生成树
		- 霍夫曼编码 
- 自顶向下计算
	- 通过贪心选择, 将原问题规约为子问题
	- 子问题的最优解递推到最终问题的最优解
- 基本思想
	- 建立数学模型来描述问题
	- 把求解的问题分成若干个子问题
	- 对每一子问题求解, 得到子问题的局部最优解
	- 把子问题的解局部最优解合成原来解问题的一个解
	- <mark>Note:对所采用的贪心策略一定要仔细分析其是否满足 “无后效性”</mark>
- 算法过程
	- 从问题的某一初始解出发；
	- while 能朝给定总目标前进一步 do ,求出可行解的一个解元素；
	- 最后，由所有解元素组合成问题的一个可行解。

### 誊抄书籍

- 问题描述：
	- 有`m`本书需要誊抄, 每本书的页数分别是 `(p1, p2, …, pm)`
	- 有 k (k <= m) 个抄写员负责誊抄这些书籍
	- 任 务
		- 将这些书分成 k 份, 每本书必须只分给一个抄写员
		- 每个抄写员至少分到一本
		- 要求每个抄写员分到的书的编号是连续的
		- 即存在一个连续升序数列 `0=b0＜b1＜b2＜…＜bk-1＜bk=m`
			- 第`i`号抄写员得到的书稿是从`bi-1+1` 到第`bi`本书
	- 问题
		- 抄写工作同时开始，抄写员抄写速度一样，先抄写完的等待，抄写完所有书籍的时间取决于被分配页数最大的抄写员完成的时间
		- 求最优的分配方式使抄书时间最少
		
- 问题的输入输出

```
样例输入:
2 // 2个case
9 3 //case1: 9本书，3个抄写员
100 200 300 400 500 600 700 800 900  //case1: 每本书的页数
5 4 //case2: 5 4
100 100 100 100 100 //case2: 每本书的页数
样例输出:
100 200 300 400 500/600 700/800 900 case1: 每位抄写员抄写数量通过/分割
100/100/100/100 100 case2: 每位抄写员抄写数量通过/分割
```

- 解题思路
凭经验思考下，能得到两个思路：

1. 尽量让每个人抄写的书的页数平均，这样减少等待时间
2. 尽量减少页数最多那个抄书员所抄写的页数，平均到其它人身上

按照这两个思路继续思考，可以先求出书的总页数`S = 4500`, 平均到每个人身上有`S/3 = 1500`页，这个值可以作为阈值`x`，接下来可以将书按照序号累加，如果超过`x`就舍掉这一本，将前面的书分给一个人，后面的书分给下一个人，重新累加。依次递推可以的得到：

```
100 + 200 + 300 + 400 + 500 = 1500; //第一个人
600 + 700 = 1300; //第二个人
800 + 900 = 1700; //第三个人
```
则最长路径为1500，可以作为抄书的最短时间。上面的思路是一种“贪心”思路，即每一步都满足一个条件，不去考虑后面的步骤，显然这种方式未必能得到最优解。同样，上面使用平均值作为阈值的思路也没有严格的数学证明，所以不一定是准确的（生活中有些凭经验去得到的结论也未必正确）。严格的做法是通过枚举来找到确定这个阈值，而从0开始枚举带来的时间消耗又太大，因此可以使用二分法来缩小搜索范围:

```python
#下界：最多的一本书的页数（因为没人至少分配一本书）
#上界：总页数
#x = （ 上界 + 下界 ）/ 2

books = [100, 200, 300, 400, 500, 600, 700, 800, 900]  #每本书页数
k = 3  # 抄写员人数

def check(x):
    cur_pages = 0 #当前堆的总页数
    piles = 0 #总堆数
    for i in reversed(books): #反向遍历book数组
        if (cur_pages + i > x): #如果超过了x
            piles += 1 #则堆数+1
            cur_pages = i #下一堆的起始页数
        else:
            cur_pages += i #当前堆页数继续累加
    if cur_pages > 0: 
        piles += 1 #循环完，如果cur_pages > 0 ，总数+1

    return  piles<=k  #如果总堆数 > 总人数，说明x值太小了，需要增大。反之需要减少

#二分查找
l = max(books)
r = sum(books)
while(l <= r):
    mid = math.ceil((l+r)/2)
    result = check(mid)
    if(result):
        r = mid-1
    else:
        l = mid + 1

print(l, r)
```

经过上面计算，得到的`x`取值为1700。离经验值1500有些差距。上面的思路是一种“二分+判定”的贪心策略，使用二分法查找阈值`x`，使用堆数必须小于`k`个抄书员作为判定条件。这种思路是一种通用的解题策略

## 枚举

- 基于已有知识进行**答案猜测**的一种问题求解策略
    - 例如求解小于N的最大素数。求解策略为
        - 2是素数, 记为PRIM0
        - 根据PRIM0，PRIM1, …, PRIMk, 寻找比PRIMk大的最小素数PRIMk+1
        - 如果PRIMk+1大于N, 则PRIMk是我们需要找的素数,否则继续寻找
- 核心思想是**猜和测**，从可能的集合中一 一列举各元素
    -  根据所知道的知识, 给一个猜测的答案，比如2是素数
- 枚举算法
    - 对问题可能解集合的每一项
    - 根据问题给定的检验条件判定哪些是成立的
    - 使条件成立的即是问题的解
- 三个关键问题
    - 给出解空间，建立简洁的数学模型
        - 可能情况是什么
        - 模型中变量数尽可能少，他们之间相互独立
    - 减少搜索的空间
        - 利用知识缩小模型中各变量的取值范围, 避免不必要的计算
        - 减少代码中循环体执行次数
            - 除2之外, 只有奇数才可能是素数,`{2,2*i+1|1<=i, 2*i+1<n}`
    - 采用合适的搜索顺序
        - 搜索空间的遍历顺序要与模型中条件表达式一致
            - 对`{2,2*i+1|1<=i, 2*i+1<n}`按照从小到大的顺序

### 百鸡百钱

> 鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一.百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何 —— 张丘建《算经》

先分析条件：

1. `X`, `Y`, `Z`分别代表买公鸡, 母鸡和小鸡的只数
2. `5X+3Y+Z/3=100`
3. `Z%3==0`

```cpp
for(int x=0; x<=100; x++){
    for(int y=0; y<=100-x; y++){
        z = 100-x-y;
        if(z%3 == 0){
            if(5*x+3*y+z/3==100){
                //x,y,z is the solution
            }
        }
    }
}
```

## 递归

- 递归 
    — 某个函数直接或间接的调用自身的问题求解过程
    - 大问题划分成许多相同性质的子问题的求解   
    - 而小问题的求解过程可以很容易的求出
    - 这些子问题的解就构成里原问题的解

- 总体思想
    - 待求解问题的解 -> 输入变量`x`的函数`f(x)`
    - 通过寻找函数`g(x)`, 使得`f(x) = g(f(x-1))`
    - 且已知`f(0)`的值, 就可以通过`f(0)`和`g(x)`求出`f(x)`的值
- 推广
    - 扩展到多个输入变量`x, y, z`等, `x-1`也可以推广到 `x - x1`,只要递归朝着 “出口” 的方向即可

- 三个要点
    - **递归式**:如何将原问题划分成子问题
    - **递归出口**: 递归终止的条件, 即最小子问题的求解,可以允许多个出口
    - **边界函数**:问题规模变化的函数, 它保证递归的规模向出口条件靠拢

### 递归的调用过程

- <mark>递归调用是一个后进先出的深搜过程</mark>
    - 调用
        - 使用栈保存调用信息（参数，返回地址）
        - 分配数据区（局部变量）
        - 控制转移给被调函数入口
    - 返回
        - 保存返回信息
        - 退栈，释放数据区
        - 控制转移到上级函数
- 递归树
    - 递归调用可以用树形结构表示
    - 中序遍历

假设有下面的递归函数

```cpp
int f(int n){
    if(n < 2){
        return n+1;
    }else{
        return f(n/2)*f(n/4);
    }
}
```
- <mark>编译器是如何实现递归操作的呢？</mark>

我们知道每次函数调用会开辟新的函数栈空间，递归调用也不例外，只不过编译器为其在栈里插入了一些辅助元素，比如递归返回的函数地址编号`rd`：

![](/assets/images/2015/02/stack1.png)

具体来说，其调用过程如下：

1. 设置一工作栈当前工作记录
    - 保存函数中出现的所有参数和局部变量
        - 函数参数（值参，引用）
        - 局部变量
        - 返回语句标号（t+2个数值）

    ```cpp
    typedef struct elem { // 栈数据元素类型
        int rd; // 返回语句的标号
        Datatypeofp1 p1; // 函数参数
        ...
        Datatypeofpm pm;
        Datatypeofq1 q1; // 局部变量

        Datatypeofqn qn;
    } ELEM;
    ```    
2. 设置 t+2个语句标号
    - `label 0` ：第一个可执行语句
    - `label t+1` ：设在函数体结束处
    - `label i (1<=i<=t)` ： 第`i`个递归返回处
3. 增加非递归入口
    - 入栈：`S.push(t+1，p1, …，pm，q1，…qn`
4. 替换第 `i (i = 1, …, t)`个递归规则
5. 所有递归出口处增加语句：goto label t+1;
6. 标号为t+1的语句的格式
7. 改写循环和嵌套中的递归
8. 优化处理

### 递归树

还是上面例子的递归函数，由于其有返回值，我们可以将其改写成下面的样子：

```cpp
//改写后    
void exmp(int n, int& f) {
    int u1, u2;
    if (n<2){
        f = n+1;
    }else{
        exmp((int)(n/2), u1);
        exmp((int)(n/4), u2);
        f = u1*u2;
    }
}
```
    
上述递归过程的递归树如图所示，可见其实际上是一个深度优先遍历（中序遍历）的过程。

![](/assets/images/2015/02/tree1.png)

### 汉诺塔问题

> 古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。有一个和尚想把这64个盘子从A座移到C座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。在移动过程中可以利用B座，要求输出移动的步骤。

- 汉诺塔问题的规则
    - 从A座出发，移动n个盘子到B座
    - A，B，C都可以暂存
    - 大盘子不能压到小盘子
- 例如 `hano(2,'B','C','A')` 表示B座的2个盘子从B座移动到A座

- 递归解法

```python
def hano(n,src,mid,dst):
    if n == 1:
        print("from",src,"to",dst)
    else:
        hano(n-1,src,dst,mid)
        print("from",src,"to",dst)
        hano(n-1,mid,src,dst)
    
hano(3,'A','B','C')
```


## 动态规划(Dynamic Programming)

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。子问题和原问题是同一类问题，子问题解决的颗粒度更小，最后将子问题的解合并得到原问题的解。
动态规划往往比递归更高效，因为递归中有大部分的重复计算，以斐波那契数列为例，递归解法为:

```python
def fib1(n):
    if n==0 or n==1:
        return n
    else:
        return fib1(n-1)+fib1(n-2)
```
当 `n=5`时，`fib(5)`的计算过程如下:

```
fib(5)
fib(4) + fib(3)
(fib(3) + fib(2)) + (fib(2) + fib(1))
((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
```
这种算法对于相似的子问题（求解`fib(3),fib(2),fib(1),fib(0)`）进行了重复的计算，因此不是一种高效的算法，主要有两方面问题：

1. 该算法的运算时间是指数级增长的。
2. 递归很深的情况下（比如n=66），容易出现stackoverflow

<img src="/assets/images/2015/02/fib.png" width="50%"/>


如果使用动态规划，可以：

1. 将已经计算好的结果进行缓存，避免重复计算，拿空间换时间，`空间复杂度O(n)`
2. 找到递推公式，用循环代替递归

```python
def fib2(n):
    l = list(range(0,n+1)) #缓存计算好的结果
    #确定初始状态
    l[0] = 0 
    l[1] = 1 
    #循环递推代替多层递归
    for i in range(2,n+1):
        l[i] = l[i-1]+l[i-2]

    return l[n]
```

对于递归问题，我们可以用以下方法，将其转化为动归问题：

1. 递归函数有n个参数，就定义一个n为数组
2. 数组的下标是递归函数参数的取值范围
3. 数组的元素值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程


### 动态规划解题的一般步骤

1. 将原问题分解为子问题
    - 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题解决，原问题即解决
    - 子问题的解<mark>可以缓存</mark>，所以每个子问题只需要求解一次

2. 确定状态
    - 将和子问题相关的各个变量的一组取值，称之为一个`状态`，一个`状态`对应于一个或多个子问题，所谓某个`状态`下的`值`，就是这个状态所对应的子问题的`解`
    - 所有`状态`的集合，构成问题的`状态空间`。状态空间的大小解解决问题的时间复杂度直接相关。整个问题的时间复杂度是<mark>状态数目乘以每个状态所需要的时间</mark>
    - 经常碰到的情况是，K个整型变量能够成一个状态。如果这个K个整型变量的取值范围分别是`N1,N2,...,Nk`，那么，我们就可以用一个K维数组`array[N1][N2]...[Nk]`来存储各个状态的`值`。这个`值`未必是一个整数或浮点数，也可以是一个复杂的数据结构
3. 确定一些初始状态（边界状态）的值
4. 确定状态转移方程
    - 找到不同状态之间如何迁移-即如何从一个或多个值已知的状态，求出另一个状态的值。状态的迁移可以用递推公式表示，递推公式也可被称作<mark>状态转移方程</mark>
        - 递推公式可以从前往后推导，也可以从后向前推导 
    - 当选取的状态，难以进行递推时（分解出的子问题和原问题形式不一样，或不具有无后效性），考虑将状态<mark>增加限制条件后分类细化，即增加维度</mark>，然后在新的状态上尝试递推

### 能用动规解决问题的特点

1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质
2. <mark>无后效性</mark>。当前的若干状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前的状态无关


### 求解最长上升子序列

求解上升子序列是动态规划中比较经典的NP问题，问题如下：

> 一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).你的任务，就是对于给定的序列，求出最长上升子序列的长度。

- 将原问题拆解成若干个子问题

将求解`F(n)`最大子序列长度的问题分解为求以`ak(k=1, 2, 3...N`)为终点的最长上升子序列的长度，即求`F(1)`,`F(2)`,`F(3)`...`F(n)`的最大子序列长度，再从中选取一个最大值

- 确定状态

每个子问题只和一个状态有关，即数字的位置`k`，而状态`k`对应的值为以`ak`做为终点的最长上升子序列的长度。状态个数为`N`

- 确定状态转移方程

假设对于第`k`个位置的最长子序列值为`maxLen(k)`, 要找到它和前面值的递推关系，则有:

```
maxLen(1) = 1
maxLen(k) = max{ maxLen(i) | 1<=i<k and ai < ak and k != 1 } + 1
```
`maxLen(k)`的值，就是在`ak`左边，“终点”数值小于`ak` ，且长度最大的那个上升子序列的长度再加`1`。因为`ak`左边任何“终点”小于`ak`的子序列，加上`ak`后就能形成一个更长的上升子序列。

```c
int a[n];
int maxLen[n];
for(int i=2; i<n; i++){
    for(int j=1; j<i; j++){
        if(a[i]>a[j]){
            maxLen[i] = max(maxLeb[i],maxLen[j]+1)
        }
    }
}
```

## 深度搜索

将问题的各状态之间的转移关系描述为一个<mark>图</mark>,则深度优先搜索遍历整个图的框架为：

```cpp
Dfs(v) {
    if( v 访问过)
        return;

    //1.将v标记为访问过;
    v.is_visited = true
    
    //2.(不是必须)设置某些状态
    setFlags();
    //3.对和u相邻的每个点v进行递归:
    Dfs(v);
    //4.(不是必须)回溯，如果当前搜索不符合条件，重置状态
    setFlags();
}
int main() {
    while(在图中能找到未访问过的点 k)
        Dfs(k);
}
```

也可以用栈来实现递归

```cpp
struct Obj{
    bool is_visited
    Obj(x);
};
void DFS(v){
    stack<Obj> stk;
    Obj root = Obj(v)
    while(!stk.empty()){
        Obj o = stk.top();
        if(o.is_visited){
            stk.pop();
        }else{
            o.is_visited == true;
            if (some_condition){
                Obj o' = Obj(v')
                stk.push(o')
            }
        }
    }
}
```
### Sudoku

求解数独问题是一个典型的DFS搜索问题，数独问题描述如下:
> 将数字1到9,填入9x9矩阵中的小方格，使得矩阵中的每行，每列，每个3x3的小格子内，9个数字都会出现"。
程序的输入(左边，其中`0`为待填充部分)，输出(右边)为:

<div style=" content:''; display: table; clear:both; height=0">
    <div style="width:110px; float:left">
        1 0 3 0 0 0 5 0 9
        0 0 2 1 0 9 4 0 0
        0 0 0 7 0 4 0 0 0
        3 0 0 5 0 2 0 0 6
        0 6 0 0 0 0 0 5 0
        7 0 0 8 0 3 0 0 4
        0 0 0 4 0 1 0 0 0
        0 0 9 2 0 5 8 0 0
        8 0 4 0 0 0 1 0 7
    </div>
    <div style="width:110px; margin-left:15px;float:left">
        1 4 3 6 2 8 5 7 9 
        5 7 2 1 3 9 4 6 8 
        9 8 6 7 5 4 2 3 1 
        3 9 1 5 4 2 7 8 6 
        4 6 8 9 1 7 3 5 2 
        7 2 5 8 6 3 9 1 4 
        2 3 7 4 8 1 6 9 5 
        6 1 9 2 7 5 8 4 3 
        8 5 4 3 9 6 1 2 7
    </div>
</div>

- 解题思路

这个题目的解法可以通过枚举空白处所有可能的情况，解法相对暴利。由于所有每个位置的解依赖它前面的解，因此这是一个深度搜索的过程。

```cpp
//确定数据结构：
int col[9][10]; //标志位，存放每列1-9出现的标志，1为放置，0为未放置
int row[9][10]; //标志位，存放每行1-9出现的标志，1为放置，0为未放置
int block[9][10]; //标志位，存放每个小块1-9出现的标志，1为放置，0为未放置
int board[9][9]; //棋盘
struct Value{
    int row;
    int col;
};//棋盘中的每个点
vector<Value> blanks; //待填充的空白数字

...

//可放置数字的条件
bool can_be_placed(int r, int c, int num){
    if( row[r][num] == 0 &&
        col[c][num] == 0 &&
        block[block_index(r,c)][num] == 0){
        return true;
    }
    return false;
}

//深度搜索过程
bool DFS(int index){
    if(index < 0){
        return true;
    }
    int row = blanks[index].row;
    int col = blanks[index].col;
    for(int num=1;num<=9;num++){
        //枚举num，如果可以被放置
        if(can_be_placed(row, col, num)){
            //填充板子上的值
            board[row][col] = num;
            //设置状态
            set_state(row,col,num);
            //继续递归
            if(DFS(index-1)){
                return true;
            }else{
                //递归失败，回溯清空状态
                clear_state(row,col,num);
            }
        }
    }
    return false;
}

```

## 广度优先搜索

广度搜索相比深度搜索，只需要知道目标节点位于第几层，便可确定到达的路径数目，可以确保找到最优解，因此通常用于求解层次相关问题（步数问题，路径问题）。广搜在遍历的过程中，通常使用队列存储节点，对每一个节点，可以用一个结构定义：

```cpp
struct node{
    int value;
    int layer; //在第几层的位置
    bool isVisited; //是否被遍历过
    node* parent; //便于路径搜索
    vector<node* >children; //该节点所能到到的子节点
}
```

### 广搜算法

1. 将初始节点`s0`放入Queue中
2. 如果Queue为空，则问题无解，失败退出
3. 从Queue中取出第一个节点，记为`n`, 将其状态标记为visit
4. 考察`n`是否为目标节点，若是，则退出
5. 若`n`不是目标节点，则看`n`是否有子节点，若没有，则转到第2步
6. 遍历`n`的子节点，如果没有被visit·，则放入Queue中，转到第2步

```cpp
void bfs{
    queue<node> q;
    q.push(node(x));
    
    while(!q.empty()){
        node = q.front();
        node.isVisited = true;
        if(node.value==K){ //找到目标
            return；
        }
        for(auto child : node.children){
            if(!child.isVisited){
                q.push(child);
            }
        }
        q.pop();
    }
}
```

广度搜索的一个重点是要先构造**状态空间**，即如何从一个状态，生成一棵树，树中的每个节点对应状态空间的一个状态。而状态空间的生成是一个逐层扩展的过程，枚举根节点所能到达的状态构成第二层状态，这些状态可以作为根节点的子节点，依次类推展开完整的空间。

### 广搜与深搜的比较

- 广搜一般用于状态表示比较简单、求最优策略的问题
    - 优点：**是一种完备策略**，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，**还一定是路径最短的解**。
    - 缺点：盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大

- 深搜几乎可以用于任何问题
    - 只需要保存从起始状态到当前状态路径上的节点

### 双向BFS

- DBFS算法是对BFS算法的一种扩展。
    - BFS算法从起始节点以广度优先的顺序不断扩展，直到遇到目的节点
    - DBFS算法从两个方向以广度优先的顺序同时扩展，一个是从起始节点开始扩展，另一个是从目的节点扩展，直到一个扩展队列中出现另外一个队列中已经扩展的节点，也就相当于两个扩展方向出现了交点，那么可以认为我们找到了一条路径
- 比较
    - DBFS算法相对于BFS算法来说，由于采用了双向扩展的方式，搜索树的宽度得到了明显的减少，时间复度和空间复杂度上都有提高！
    - 假设1个节点能扩展出n个节点，单向搜索要m层能找到答案，那么扩展出来的节点数目就是:`(1-n^m)/(1-n)`
    - 双向广搜，同样是一共扩展m层，假定两边各扩展出`m/2`层，则总节点数目 `2 * (1-n^m/2)/(1-n)`
    - 每次扩展节点总是选择节点比较少的那边进行扩展，并不是机械
的两边交替。

- 实现思路

```
void dbfs()
{
    1. 将起始节点放入队列q0,将目标节点放入队列q1；
    2. 当两个队列都未空时，作如下循环：
        1) 如果队列q0里的节点比q1中的少,则扩展队列q0；
        2) 否则扩展队列q1
    3. 如果队列q0未空，不断扩展q0直到为空；
    4. 如果队列q1未空，不断扩展q1直到为空；
}
int expand(i) //其中i为队列的编号，0或1
{
    取队列qi的头节点H；
    对H的每一个相邻节点adj：
    1 如果adj已经在队列qi之中出现过，则抛弃adj；
    2 如果adj在队列qi中未出现过，则:
    1） 将adj放入队列qi；
    2) 如果adj 曾在队列q1-i中出现过, 则：输出找到的路径
} 
```

### Resources

- [算法基础](https://www.coursera.org/learn/suanfa-jichu)
- [算法设计与分析](https://www.coursera.org/learn/algorithms)
- [Algorithms(stanford)](https://www.coursera.org/specializations/algorithms)
