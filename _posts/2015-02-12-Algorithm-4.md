---
layout: post
title: Algorithm Part 4
---

## 朴素的算法思想

这一篇我们来继续聊一聊一些经典的计算机算法，包括：二分查找，贪心，动态规划，深搜，广搜等

### 二分查找

- 前提：有序序列
- 方法：折半查找

```
left = 0, right = n-1
while( left < right ){
	mid = (left+right)/2
	if(x[mid] < t){
		left = mid + 1;
	}else if(x[mid] == t){
		p = mid;
		break;
	}eles{
		right = mid-1;
	}
}
```

### 贪心法

- 求最优化解问题
	- 问题求解时, 总是做出在当前看来是最好的选择，不保证全局最优
		- 旅行推销员问题，每次选择最近城市
		- 换零钱问题，每次拿面值最大的
		- 图的最小生成树
		- 霍夫曼编码 
- 自顶向下计算
	- 通过贪心选择, 将原问题规约为子问题
	- 子问题的最优解递推到最终问题的最优解
- 基本思想
	- 建立数学模型来描述问题
	- 把求解的问题分成若干个子问题
	- 对每一子问题求解, 得到子问题的局部最优解
	- 把子问题的解局部最优解合成原来解问题的一个解
	- <mark>Note:对所采用的贪心策略一定要仔细分析其是否满足 “无后效性”</mark>
- 算法过程
	- 从问题的某一初始解出发；
	- while 能朝给定总目标前进一步 do ,求出可行解的一个解元素；
	- 最后，由所有解元素组合成问题的一个可行解。

### 誊抄书籍

- 问题描述：
	- 有`m`本书需要誊抄, 每本书的页数分别是 `(p1, p2, …, pm)`
	- 有 k (k <= m) 个抄写员负责誊抄这些书籍
	- 任 务
		- 将这些书分成 k 份, 每本书必须只分给一个抄写员
		- 每个抄写员至少分到一本
		- 要求每个抄写员分到的书的编号是连续的
		- 即存在一个连续升序数列 `0=b0＜b1＜b2＜…＜bk-1＜bk=m`
			- 第`i`号抄写员得到的书稿是从`bi-1+1` 到第`bi`本书
	- 问题
		- 抄写工作同时开始，抄写员抄写速度一样，先抄写完的等待，抄写完所有书籍的时间取决于被分配页数最大的抄写员完成的时间
		- 求最优的分配方式使抄书时间最少
		
- 问题的输入输出

```
样例输入:
2 // 2个case
9 3 //case1: 9本书，3个抄写员
100 200 300 400 500 600 700 800 900  //case1: 每本书的页数
5 4 //case2: 5 4
100 100 100 100 100 //case2: 每本书的页数
样例输出:
100 200 300 400 500/600 700/800 900 case1: 每位抄写员抄写数量通过/分割
100/100/100/100 100 case2: 每位抄写员抄写数量通过/分割
```

- 解题思路
凭经验思考下，能得到两个思路：

1. 尽量让每个人抄写的书的页数平均，这样减少等待时间
2. 尽量减少页数最多那个抄书员所抄写的页数，平均到其它人身上

按照这两个思路继续思考，可以先求出书的总页数`S = 4500`, 平均到每个人身上有`S/3 = 1500`页，这个值可以作为阈值`x`，接下来可以将书按照序号累加，如果超过`x`就舍掉这一本，将前面的书分给一个人，后面的书分给下一个人，重新累加。依次递推可以的得到：

```
100 + 200 + 300 + 400 + 500 = 1500; //第一个人
600 + 700 = 1300; //第二个人
800 + 900 = 1700; //第三个人
```
则最长路径为1500，可以作为抄书的最短时间。上面的思路是一种“贪心”思路，即每一步都满足一个条件，不去考虑后面的步骤，显然这种方式未必能得到最优解。同样，上面使用平均值作为阈值的思路也没有严格的数学证明，所以不一定是准确的（生活中有些凭经验去得到的结论也未必正确）。严格的做法是通过枚举来找到确定这个阈值，而从0开始枚举带来的时间消耗又太大，因此可以使用二分法来缩小搜索范围:

```
#下界：最多的一本书的页数（因为没人至少分配一本书）
#上界：总页数
#x = （ 上界 + 下界 ）/ 2

books = [100, 200, 300, 400, 500, 600, 700, 800, 900]  #每本书页数
k = 3  # 抄写员人数

def check(x):
    cur_pages = 0 #当前堆的总页数
    piles = 0 #总堆数
    for i in reversed(books): #反向遍历book数组
        if (cur_pages + i > x): #如果超过了x
            piles += 1 #则堆数+1
            cur_pages = i #下一堆的起始页数
        else:
            cur_pages += i #当前堆页数继续累加
    if cur_pages > 0: 
        piles += 1 #循环完，如果cur_pages > 0 ，总数+1

    return  piles<=k  #如果总堆数 > 总人数，说明x值太小了，需要增大。反之需要减少

#二分查找
l = max(books)
r = sum(books)
while(l <= r):
    mid = math.ceil((l+r)/2)
    result = check(mid)
    if(result):
        r = mid-1
    else:
        l = mid + 1

print(l, r)
```

经过上面计算，得到的`x`取值为1700。离经验值1500有些差距。上面的思路是一种“二分+判定”的贪心策略，使用二分法查找阈值`x`，使用堆数必须小于`k`个抄书员作为判定条件。这种思路是一种通用的解题策略

## 枚举

- 基于已有知识进行**答案猜测**的一种问题求解策略
    - 例如求解小于N的最大素数。求解策略为
        - 2是素数, 记为PRIM0
        - 根据PRIM0，PRIM1, …, PRIMk, 寻找比PRIMk大的最小素数PRIMk+1
        - 如果PRIMk+1大于N, 则PRIMk是我们需要找的素数,否则继续寻找
- 核心思想是**猜和测**，从可能的集合中一 一列举各元素
    -  根据所知道的知识, 给一个猜测的答案，比如2是素数
- 枚举算法
    - 对问题可能解集合的每一项
    - 根据问题给定的检验条件判定哪些是成立的
    - 使条件成立的即是问题的解
- 三个关键问题
    - 给出解空间，建立简洁的数学模型
        - 可能情况是什么
        - 模型中变量数尽可能少，他们之间相互独立
    - 减少搜索的空间
        - 利用知识缩小模型中各变量的取值范围, 避免不必要的计算
        - 减少代码中循环体执行次数
            - 除2之外, 只有奇数才可能是素数,`{2,2*i+1|1<=i, 2*i+1<n}`
    - 采用合适的搜索顺序
        - 搜索空间的遍历顺序要与模型中条件表达式一致
            - 对`{2,2*i+1|1<=i, 2*i+1<n}`按照从小到大的顺序

### 百鸡百钱

> 鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一.百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何 —— 张丘建《算经》

先分析条件：

1. `X`, `Y`, `Z`分别代表买公鸡, 母鸡和小鸡的只数
2. `5X+3Y+Z/3=100`
3. `Z%3==0`

```cpp
for(int x=0; x<=100; x++){
    for(int y=0; y<=100-x; y++){
        z = 100-x-y;
        if(z%3 == 0){
            if(5*x+3*y+z/3==100){
                //x,y,z is the solution
            }
        }
    }
}
```

## 递归

- 递归 — 某个函数直接或间接的调用自身的问题求解过程
    - 大问题划分成许多相同性质的子问题的求解   
    - 而小问题的求解过程可以很容易的求出
    - 这些子问题的解就构成里原问题的解

- 总体思想
    - 待求解问题的解 -> 输入变量`x`的函数`f(x)`
    - 通过寻找函数`g(x)`, 使得`f(x) = g(f(x-1))`
    - 且已知`f(0)`的值, 就可以通过`f(0)`和`g( )`求出`f(x)`的值
- 推广
    - 扩展到多个输入变量`x, y, z`等, `x-1`也可以推广到 `x - x1`,只要递归朝着 “出口” 的方向即可

- 递归与枚举的区别
    - 枚举:
        - 把一个问题划分成一组子问题, 依次对这些子问题求解
        - 子问题之间是横向的, 同类的关系
    - 递归:
        - 把一个问题逐级分解成子问题
        - 子问题与原问题之间是纵向的, 同类的关系
    - 语法形式上: 在一个函数的运行过程中, 调用这个函数自己
        - 直接调用: 在`fun()`中直接执行`fun()`
        - 间接调用: 在`fun1()`中执行`fun2()`; 在`fun2()`中又执行`fun1()`

- 三个要点
    - **递归式**:如何将原问题划分成子问题
    - **递归出口**: 递归终止的条件, 即最小子问题的求解,可以允许多个出口
    - **边界函数**:问题规模变化的函数, 它保证递归的规模向出口条件靠拢

- 递归解决问题的关键
    - 找出递推公式
    - 找到递归终止条件
- **注意事项**: 由于函数的局部变量是存在栈上的如果有体积大的局部变量, 比如数组,而递归层次可能很深的情况下, 也许会导致栈溢出，可以考虑使用全局数组或动态分配数组

### 迷宫求解
- 自相似性：每一步走的探测方式相同
- 通过<mark>枚举+递归</mark>方式找到从起点到终点的路径，Search过程如下
    - 朝一个方向走下去，如果走不通，换个方向
    - 四个方向都不通，回到上一步的地方换方向走
    - 以此类推，直到终点
- 描述迷宫
    - 使用二维数组描述行列
    - 搜索过程中，用另外一个二维数组标记各自是否已经走过了
    - 其它变量
        - `minstep`,起点到终点的最少路径数，初始化值为int_max
        - `w,h`，迷宫的宽高
- 枚举行走方向
    - 另`(x,y)`表示行走步长，每步有上下左右四中可能走法，因此会产生8个值，定义一个`int[4][2]`存储可能情况
        - `int to[4][2] = { {1,0},{0,1},{-1,0},{0,-1} }`
        - 枚举向上下左右走

        ```c
        for(int i=0;i<4;++i){
            int x = now_x + to[i][0];
            int y = now_y + to[i][1];
            //新的点(x,y)
            int direction = i; //0，1，2，分别表示右，向上，向左，向下
        }
        ```
- 判断当前点`(x,y)`是否有效
    - T1:在边界之内:`(x>-1) && (x<W+2) && (y>-1) && (y<h+2)`
    - T2:该位置不曾走过:`mark[y][x] = false`
    - T3:到达终点：`(x==end_x)&&(y==end_y)&&(board[y][x]=='x')
    - `(x,y)`有效的条件是`T1&&(T2||T3)`    
- 构造递归函数
    
```c
//now_x,now_y当前位置
//end_x, end_y结束位置
//step已经走过的路径数目
//f从上一步走到(now_x,now_y)时的方向
void search(int now_x, int now_y, int end_x, int end_y,int step, int f){
    //step0: 检查递归条件
    //当前路径数目大于minstep，说明这条路径不是最优路径
    if(step > minstep) 
        return;
    if(now_x == end_x && now_y == end_y){//到达终点
        //如果这条路径的step比minstep小，更新最小路径数
        if(minstep>step) {
            minstep = step;
            return;
        }
    }
    //step1：枚举下一步方向
    for(int i=0;i<4;++i){
        int x = now_x + to[i][0];
        int y = now_y + to[i][1];
        //step3: 检查新的点(x,y)的合法性
        if(T1&&T2||T3){
            mark[y][x] = true; //标记该位置有效
            if(f == i){//上一步方向和当前方向相同
                //递归
                search(x,y,end_x,end_y,step,i);
            }else{//否则尝试新路径，step+1
                search(x,y,end_x,end_y,step+1,i);
            }
            //所有递归完成后，发现此路不通，则将走过的标记清空
            mark[k][x]=false;
        }
    }
}
```

## 动态规划(Dynamic Programming)

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。子问题和原问题是同一类问题，子问题解决的颗粒度更小，最后将子问题的解合并得到原问题的解。
动态规划往往比递归更高效，因为递归中有大部分的重复计算，以斐波那契数列为例，递归解法为:

```python
def fib1(n):
    if n==0 or n==1:
        return n
    else:
        return fib1(n-1)+fib1(n-2)
```
当 `n=5`时，`fib(5)`的计算过程如下:

```
fib(5)
fib(4) + fib(3)
(fib(3) + fib(2)) + (fib(2) + fib(1))
((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
```
这种算法对于相似的子问题（求解`fib(3),fib(2),fib(1),fib(0)`）进行了重复的计算，因此不是一种高效的算法，主要有两方面问题：

1. 该算法的运算时间是指数级增长的。
2. 递归很深的情况下（比如n=66），容易出现stackoverflow

<img src="/assets/images/2015/02/fib.png" width="50%"/>


如果使用动态规划，可以：

1. 将已经计算好的结果进行缓存，避免重复计算，拿空间换时间，`空间复杂度O(n)`
2. 找到递推公式，用循环代替递归

```python
def fib2(n):
    l = list(range(0,n+1)) #缓存计算好的结果
    #确定初始状态
    l[0] = 0 
    l[1] = 1 
    #循环递推代替多层递归
    for i in range(2,n+1):
        l[i] = l[i-1]+l[i-2]

    return l[n]
```

- 递归问题转为动归的一般方法为
    - 递归函数有n个参数，就定义一个n为数组，数组的下标是递归函数参数的取值范围，数组的元素值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程


### 动态规划解题的一般步骤

1. 将原问题分解为子问题
    - 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题解决，原问题即解决
    - 子问题的解<mark>可以缓存</mark>，所以每个子问题只需要求解一次

2. 确定状态
    - 将和子问题相关的各个变量的一组取值，称之为一个`状态`，一个`状态`对应于一个或多个子问题，所谓某个`状态`下的`值`，就是这个状态所对应的子问题的`解`
    - 所有`状态`的集合，构成问题的`状态空间`。状态空间的大小解解决问题的时间复杂度直接相关。整个问题的时间复杂度是<mark>状态数目乘以每个状态所需要的时间</mark>
    - 经常碰到的情况是，K个整型变量能够成一个状态。如果这个K个整型变量的取值范围分别是`N1,N2,...,Nk`，那么，我们就可以用一个K维数组`array[N1][N2]...[Nk]`来存储各个状态的`值`。这个`值`未必是一个整数或浮点数，也可以是一个复杂的数据结构
3. 确定一些初始状态（边界状态）的值
4. 确定状态转移方程
    - 找到不同状态之间如何迁移-即如何从一个或多个值已知的状态，求出另一个状态的值。状态的迁移可以用递推公式表示，递推公式也可被称作<mark>状态转移方程</mark>
        - 递推公式可以从前往后推导，也可以从后向前推导 
    - 当选取的状态，难以进行递推时（分解出的子问题和原问题形式不一样，或不具有无后效性），考虑将状态<mark>增加限制条件后分类细化，即增加维度</mark>，然后在新的状态上尝试递推

### 能用动规解决问题的特点

1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质
2. <mark>无后效性</mark>。当前的若干状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前的状态无关


### 求解最长上升子序列

求解上升子序列是动态规划中比较经典的NP问题，问题如下：

> 一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).你的任务，就是对于给定的序列，求出最长上升子序列的长度。

- 将原问题拆解成若干个子问题

将求解`F(n)`最大子序列长度的问题分解为求以`ak(k=1, 2, 3...N`)为终点的最长上升子序列的长度，即求`F(1)`,`F(2)`,`F(3)`...`F(n)`的最大子序列长度，再从中选取一个最大值

- 确定状态

每个子问题只和一个状态有关，即数字的位置`k`，而状态`k`对应的值为以`ak`做为终点的最长上升子序列的长度。状态个数为`N`

- 确定状态转移方程

假设对于第`k`个位置的最长子序列值为`maxLen(k)`, 要找到它和前面值的递推关系，则有:

```
maxLen(1) = 1
maxLen(k) = max{ maxLen(i) | 1<=i<k and ai < ak and k != 1 } + 1
```
`maxLen(k)`的值，就是在`ak`左边，“终点”数值小于`ak` ，且长度最大的那个上升子序列的长度再加`1`。因为`ak`左边任何“终点”小于`ak`的子序列，加上`ak`后就能形成一个更长的上升子序列。

```c
int a[n];
int maxLen[n];
for(int i=2; i<n; i++){
    for(int j=1; j<i; j++){
        if(a[i]>a[j]){
            maxLen[i] = max(maxLeb[i],maxLen[j]+1)
        }
    }
}
```

## 深度搜索

将问题的各状态之间的转移关系描述为一个<mark>图</mark>,则深度优先搜索遍历整个图的框架为：

```cpp
Dfs(v) {
    if( v 访问过)
        return;

    //1.将v标记为访问过;
    v.is_visited = true
    
    //2.(不是必须)设置某些状态
    setFlags();
    //3.对和u相邻的每个点v进行递归:
    Dfs(v);
    //4.(不是必须)回溯，如果当前搜索不符合条件，重置状态
    setFlags();
}
int main() {
    while(在图中能找到未访问过的点 k)
        Dfs(k);
}
```

也可以用栈来实现递归

```cpp
struct Obj{
    bool is_visited
    Obj(x);
};
void DFS(v){
    stack<Obj> stk;
    Obj root = Obj(v)
    while(!stk.empty()){
        Obj o = stk.top();
        if(o.is_visited){
            stk.pop();
        }else{
            o.is_visited == true;
            if (some_condition){
                Obj o' = Obj(v')
                stk.push(o')
            }
        }
    }
}
```
### Sudoku

求解数独问题是一个典型的DFS搜索问题，数独问题描述如下:
> 将数字1到9,填入9x9矩阵中的小方格，使得矩阵中的每行，每列，每个3x3的小格子内，9个数字都会出现"。
程序的输入(左边，其中`0`为待填充部分)，输出(右边)为:

<div style=" content:''; display: table; clear:both; height=0">
    <div style="width:110px; float:left">
        1 0 3 0 0 0 5 0 9
        0 0 2 1 0 9 4 0 0
        0 0 0 7 0 4 0 0 0
        3 0 0 5 0 2 0 0 6
        0 6 0 0 0 0 0 5 0
        7 0 0 8 0 3 0 0 4
        0 0 0 4 0 1 0 0 0
        0 0 9 2 0 5 8 0 0
        8 0 4 0 0 0 1 0 7
    </div>
    <div style="width:110px; margin-left:15px;float:left">
        1 4 3 6 2 8 5 7 9 
        5 7 2 1 3 9 4 6 8 
        9 8 6 7 5 4 2 3 1 
        3 9 1 5 4 2 7 8 6 
        4 6 8 9 1 7 3 5 2 
        7 2 5 8 6 3 9 1 4 
        2 3 7 4 8 1 6 9 5 
        6 1 9 2 7 5 8 4 3 
        8 5 4 3 9 6 1 2 7
    </div>
</div>

- 解题思路

这个题目的解法可以通过枚举空白处所有可能的情况，解法相对暴利。由于所有每个位置的解依赖它前面的解，因此这是一个深度搜索的过程。

```cpp
//确定数据结构：
int col[9][10]; //标志位，存放每列1-9出现的标志，1为放置，0为未放置
int row[9][10]; //标志位，存放每行1-9出现的标志，1为放置，0为未放置
int block[9][10]; //标志位，存放每个小块1-9出现的标志，1为放置，0为未放置
int board[9][9]; //棋盘
struct Value{
    int row;
    int col;
};//棋盘中的每个点
vector<Value> blanks; //待填充的空白数字

...

//可放置数字的条件
bool can_be_placed(int r, int c, int num){
    if( row[r][num] == 0 &&
        col[c][num] == 0 &&
        block[block_index(r,c)][num] == 0){
        return true;
    }
    return false;
}

//深度搜索过程
bool DFS(int index){
    if(index < 0){
        return true;
    }
    int row = blanks[index].row;
    int col = blanks[index].col;
    for(int num=1;num<=9;num++){
        //枚举num，如果可以被放置
        if(can_be_placed(row, col, num)){
            //填充板子上的值
            board[row][col] = num;
            //设置状态
            set_state(row,col,num);
            //继续递归
            if(DFS(index-1)){
                return true;
            }else{
                //递归失败，回溯清空状态
                clear_state(row,col,num);
            }
        }
    }
    return false;
}

```

## 广度优先搜索

广度搜索相比深度搜索，只需要知道目标节点位于第几层，便可确定到达的路径数目，可以确保找到最优解，因此通常用于求解层次相关问题（步数问题，路径问题）。广搜在遍历的过程中，通常使用队列存储节点，对每一个节点，可以用一个结构定义：

```cpp
struct node{
    int value;
    int layer; //在第几层的位置
    bool isVisited; //是否被遍历过
    node* parent; //便于路径搜索
    vector<node* >children; //该节点所能到到的子节点
}
```

### 广搜算法

1. 将初始节点`s0`放入Queue中
2. 如果Queue为空，则问题无解，失败退出
3. 从Queue中取出第一个节点，记为`n`, 将其状态标记为visit
4. 考察`n`是否为目标节点，若是，则退出
5. 若`n`不是目标节点，则看`n`是否有子节点，若没有，则转到第2步
6. 遍历`n`的子节点，如果没有被visit·，则放入Queue中，转到第2步

```cpp
void bfs{
    queue<node> q;
    q.push(node(x));
    
    while(!q.empty()){
        node = q.front();
        node.isVisited = true;
        if(node.value==K){ //找到目标
            return；
        }
        for(auto child : node.children){
            if(!child.isVisited){
                q.push(child);
            }
        }
        q.pop();
    }
}
```

广度搜索的一个重点是要先构造**状态空间**，即如何从一个状态，生成一棵树，树中的每个节点对应状态空间的一个状态。而状态空间的生成是一个逐层扩展的过程，枚举根节点所能到达的状态构成第二层状态，这些状态可以作为根节点的子节点，依次类推展开完整的空间。

### 广搜与深搜的比较

- 广搜一般用于状态表示比较简单、求最优策略的问题
    - 优点：**是一种完备策略**，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，**还一定是路径最短的解**。
    - 缺点：盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大

- 深搜几乎可以用于任何问题
    - 只需要保存从起始状态到当前状态路径上的节点

### 双向BFS

- DBFS算法是对BFS算法的一种扩展。
    - BFS算法从起始节点以广度优先的顺序不断扩展，直到遇到目的节点
    - DBFS算法从两个方向以广度优先的顺序同时扩展，一个是从起始节点开始扩展，另一个是从目的节点扩展，直到一个扩展队列中出现另外一个队列中已经扩展的节点，也就相当于两个扩展方向出现了交点，那么可以认为我们找到了一条路径
- 比较
    - DBFS算法相对于BFS算法来说，由于采用了双向扩展的方式，搜索树的宽度得到了明显的减少，时间复度和空间复杂度上都有提高！
    - 假设1个结点能扩展出n个结点，单向搜索要m层能找到答案，那么扩展出来的节点数目就是:`(1-n^m)/(1-n)`
    - 双向广搜，同样是一共扩展m层，假定两边各扩展出`m/2`层，则总结点数目 `2 * (1-n^m/2)/(1-n)`
    - 每次扩展结点总是选择结点比较少的那边进行扩展，并不是机械
的两边交替。

- 实现思路

```
void dbfs()
{
    1. 将起始节点放入队列q0,将目标节点放入队列q1；
    2. 当两个队列都未空时，作如下循环：
        1) 如果队列q0里的节点比q1中的少,则扩展队列q0；
        2) 否则扩展队列q1
    3. 如果队列q0未空，不断扩展q0直到为空；
    4. 如果队列q1未空，不断扩展q1直到为空；
}
int expand(i) //其中i为队列的编号，0或1
{
    取队列qi的头结点H；
    对H的每一个相邻节点adj：
    1 如果adj已经在队列qi之中出现过，则抛弃adj；
    2 如果adj在队列qi中未出现过，则:
    1） 将adj放入队列qi；
    2) 如果adj 曾在队列q1-i中出现过, 则：输出找到的路径
} 
```

### Resources

- [算法基础](https://www.coursera.org/learn/suanfa-jichu)
- [算法设计与分析](https://www.coursera.org/learn/algorithms)
- [Algorithms(stanford)](https://www.coursera.org/specializations/algorithms)
