---
layout: post
list_title: 理解JavaScript | 常识 | Wierd Parts
title: Wierd Parts
categories: [Javascript]
---

### Motavition

一直以来JavaScript是我认为比较奇怪也是设计比较糟糕的一门语言，其原因是JavaScript中的很多概念之间是混淆不清的，比如一个对象`john`，它既可以是一个普通的`object`也可以是一个Prototype，而一个函数既可以是"构造函数"，也可以是普通函数；再比如，很奇怪的Hosting，这种设计在我看来实际上是一种bug。但是也有很多人认为这是动态语言的特点，一切都很灵活，而我的观点是JavaScript在最开始设计的时候太粗糙了，导致后面背上了沉重的历史包袱。但无论如何，这门语言目前依旧很流行，并且会一直流行下去，因此系统学习一下还是非常有必要的。本文以及后面的几篇文章会逐一分析我认为JavaScript中奇怪却又很重要的设计

> 我目前并非是JavaScript的资深开发者，还不能对这门语言做很深入的评论，因此本文以及后面的文章中或许会存在一些不准确的分析，这些问题会随着我对这门语言了解的深入而不断地被修正


### Call By Value / Call by Reference

这个问题是理解每一门编程语言都要绕不过去的问题，本质上是内存分配问题，无论是Python，C++，Java等等，比如C++中函数传参可以有传值和传引用两种方式，所谓传值就是拷贝，传引用就是传地址。理解这个问题是正确处理Side Effect的基础。

在JS中对Primary Type类型的对象传值，对Object类型的对象传引用。即是不是传参的情况，JS对象之间的赋值也是引用的传递。

```javascript
//pass by value
function change(b) { b = 2; }
var a = 1;
change(a);
console.log(a) // still 1

//pass object by reference
function changeObj(d){
    d.prop1 = "string"
}
var c =  {}
c.prop1 = {};
changeObj(c);
consloe.log(c.prop1); //string
```

### this

`this`在JS中是另一个古怪的存在，由于这门语言没有面向对象设计，因此`this`应该无从谈起，但实际上`this`却到处都有，有global的`this`，函数中有`this`，Object中也有`this`。如果说函数也是Obejct那么可以勉强解释的通，但是实际上函数中`this`却有很多坑

```javascript
function a(){
    consloe.log(this); //points to window obejct
    this.var = "hello"; //add var to window object
}
var b = function b(){
    consloe.log(this); //window obejct
}
```
但是如果这个function位于某个object内部，函数中的`this`则指向该对象

```javascript
var person = {
	firstName: "Elie",
    log:function(){
        console.log(this) //points to person obejct
    }
}
```
但是如果你认为`person`内部定义的function其`this`都指向`person`的话，那么你就错了，如果在`log`函数中定义另一个function，那么这个function中的`this`指向的是`global` object

```javascript
var person = {
	firstName: "Elie",
    log:function(){
        console.log(this) //person
        var setname = function(name){
            this.firstName = name; //this points to window object
        }
        setname("Tom");//not working 
    }
}
```
正确的做法是显式的定义一个`this`的引用

```javascript
log:function(){
    var self = this;
    var setname = function(name){
        self.firstName = name; 
    }
    setname("Tom"); 
}
```
上面几个例子我们知道了global `this`和Obejct中`this`的含义，接下来，如果一个函数中有`this`，含义又是什么呢？

```javascript
var logName = function(str1, str2){
    console.log(this.getFullName()) //wrong
}
```

上述代码中，`logName`是一个独立的函数，由前面的讨论可知，此时`this`指向global object，也就是`window`,由于`windown`中没有`getFullName`这个方法，因此上述代码执行会出错。针对上面的情况，在JavaScript中，`this`的值是可以改变的，我们可以让`this`只想一个有`getFullName`方法的对象：

```javascript
var person = {
    firstname: 'John',
    lastname: 'Doe',
    getFullName: function(){
        var fullname = this.firstname + ' ' + this.lastname;
        return fullname;
    }
}

var logName = (function(str1,str2){
    console.log(this.getFullName()) //wrong
}).bind(person)

logName() //John Doe
logName.call(person,"str1","str2") //John Doe
logName.apply(person,["str1,str2"])//John Doe
```

上述代码中令`logName`函数中的`this`指向了`person`。`bind,call,apply`这三种方式均可以改变`this`的指向，不同的是`bind`并不执行函数，只是改变`this`的值，`call`,`apply`会直接执行函数，`call`和`apply`的区别仅在传参的写法上。

凡是有`this`的函数均可以用这几种方式去改变`this`，比如

```javascript
var person2 = {
    firstname="Jane",
    lastname="Doe"
}
person.getFullName.apply(person2)
```
`bind`还以用来改变函数的行为

```javascript
function map(arr, fn){
    var ret = []
    for(let item of arr){
        ret.push(fn(item))
    }
    return ret; 
}

const arr = map([1,2,3],function(limit,item){
    return item > 1;
}.bind(this,1)) //limit的值为1
console.log(arr)
```

上面代码中，`map`接受一个参数的`fn`，但是我们调用`map`的时候，给了匿名函数两个参数，这时可调用`bind`将上述匿名函数转化成另一个函数，转化后的匿名函数相当于

```javascript
function(item){
    limit = 1;
    return item > 1;
}
```

### IIFEs

第一次看到IIFEs这种形式的JS代码，完全不知道它是干嘛的，这种写法实际上隐含了JavaScript解释器的一些规则，看下面代码

```javascript
var greeting = function(name){
    return 'Hello' + name;
}('John')
console.log(greeting);
```
这时`greeting`的类型是什么呢？string还是function？ 显然上述写法中，`greeting`变成了`string`。不难理解上述代码的执行顺序为： 

1. 匿名函数求值 
2. 将求值结果保存在`greeting`中。

为什么会这么解释，在任何编程语言中，statement和expression是两个概念，statement是普通的语句，可以是条件语句，或者定义一个函数等等，而expression则表示一个表达式，而表达式是要立刻求值的。上面代码中，当编译器看到`var greeting = `时，知道后面是一个表达式，进而对后面的匿名函数进行求值。而我们如果让编译器先看到`function`，结果会是什么样呢？

```javascript
function(name){ //wrong
    return 'Hello ' + name;
}
```

错误原因是上面的语句以`function`开头，编译器会认为它是一个函数定义的statement，而statement一定要有"主语"，即函数名，这样编译器才能将该符号注册到context中，由于上面语句没有函数名，因此报错。但是如果使用`()`将其括起来，则语义就会发生变化:

```javascript
(function(name){
    return 'Hello ' + name;
})
```

在JS中`()`包裹的statement为一个表达式expression，因此上述代码会被当做expression进行求值，显然求值的结果是得到了一个匿名函数（值得注意的是，匿名函数并没有求值）。因此该表达式的返回值是一个匿名函数，相当于

```javascript
var func = (function(name){
    return 'Hello ' + name;
})
```
如果想要执行这个匿名函数，则需要显式调用它

```javascript
//#1
(function(name){
    return 'Hello ' + name;
})("John")

//#2
(function(name){
    return 'Hello ' + name;
}("John"))
```
这样，上述代码就变成了两个表达式。如果是第一种写法，则第一个`()`表达式返回了一个匿名函数，第二表达式是匿名函数调用得到一个string；如果是第二种写法，则第一个表达式为函数求值，返回一个string，第二个表达式为`()`什么也没做，直接返回该string。

<mark>这两种写法的结果一样，但是表达式的执行顺序却不同。</mark>

这种方式对于隔离全局变量很有帮助，由于JS没有命名空间，函数外定义的的变量都是全局的，如果我们想要执行一段代码又不污染全局变量，使用IIFE是一种好的方式

### Closures

```javascript
function greet(str1){
    return function(str2){
        console.log(str1+' '+str2)
    }
}
var func2 = greet("Hi")
func2("Tony") //Hi Tony
```

上面代码中，按照常理理解，在执行`func2`之前，`greet`函数已经执行完了，`str1`应该已经被释放了，为什么在执行`func2`的时候还能访问到`str1`呢？如果熟悉其它编程语言的Closure，比如C++的Lambda表达式，Objective-C的Block等，那么这个问题就不难理解。从现象看，是`str1`被`str2`所在的匿名函数给capture了，至于是怎么capture的，无外乎两种策略，拷贝或者引用，按照前面小节的推断，如果`str1`是Primary Type，那么应该是拷贝，如果是Object类型，那么应该是传引用。但是对于Closures，无论任何数据类型，均是传引用，下面是一个经典的例子：

```javascript
function buildFunctions(){
    var arr = [];
    for(var i =0; i<3;i++){
        arr.push(function(){
            console.log(i);
        })
    }
    return arr;
}

var fs = buildFunctions();
fs[0](); //3
fs[1](); //3
fs[2](); //3
```
通过这个例子可以看出，即使是`i`作为int型的Primary Type，对于Closure而言，保存的仍是它的引用。

Closure这个特性可用来做异步任务，异步任务的回调函数可以capture在执行任务前的变量，比如

```javascript
function timer_func(){
    var greeting = "Hi!";
    setTimeout(function(){
        console.log(greeting);
    },3000);
}
```

### Resources

- [JavaScripts: The Good Part](https://7chan.org/pr/src/OReilly_JavaScript_The_Good_Parts_May_2008.pdf)
- [JavaScripts: Understanding the wierd parts](ttps://www.udemy.com/understand-javascript)