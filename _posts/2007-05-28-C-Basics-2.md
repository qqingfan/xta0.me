---
title: More on C
layout: post
---

## 使用GDB & LLDB

> 使用GDB调试需要有debug symbol，编译时可以通过`-g`生成

### GDB tricks

- `gdb --args [PROGRAM]` Normally, gdb takes arguments you give it and assumes they are for itself. Using --args passes them to the program.

- `thread apply all bt` .Dump a backtrace for all threads. It’s very useful.

- `gdb --batch --ex run --ex bt --ex q --args [PROGRAM] [ARGS]`Run the program so that if it bombs, you get a backtrace.


### GDB参考

- `run [args]` Start your program with `[args]`.
- `break [file:]` function Set a break point at [file:]function. You can also use b.
- `backtrace` Dump a backtrace of the current calling stack. Shorthand is `bt`.
- `print expr` Print the value of expr. Shorthand is `p`.
- `continue` Continue running the program. Shorthand is `c`.
- `next` Next line, but step over function calls. Shorthand is `n`.
- `step` Next line, but step into function calls. Shorthand is `s`.
- `quit` Exit GDB.
- `help` List the types of commands. You can then get help on the class of command as well as
the command.
- `cd`, `pwd`, `make` just like running these commands in your shell.
- `shell` Quickly start a shell so you can do other things.
- `clear` Clear a breakpoint.
- `info break`, `info watch` Show information about breakpoints and watchpoints.
- `attach pid` Attach to a running process so you can debug it.
- `detach` Detach from the process.
- `list` List out the next ten source lines. Add a  to list the previous ten lines.

### LLDB参考

- `run [args]` Start your program with [args].
- `breakpoint set --name [file:]function` Set a break point at [file:]function. You can also
use `b`, which is way easier.
- `thread backtrace` Dump a backtrace of the current calling stack. Shorthand is `bt`.
- `print expr` Print the value of expr. Shorthand is `p`.
- `continue` Continue running the program. Shorthand is `c`.
- `next` Next line, but step over function calls. Shorthand is `n`.
- `step` Next line, but step into function calls. Shorthand is `s`.
- `quit` Exit LLDB.
- `help` List the types of commands. You can then get help on the class of command as well as
the command itself.
- `cd`, `pwd`, `make` just like running these commands in your shell.
- `shell` Quickly start a shell so you can do other things.

## C Makefile

### 简单的Makefile

当一个工程很大，有很多文件时，使用gcc去编译就局限了。这个时候通常使用makefile，makefile中，需要把这些文件组织到一起。
makefile是一个纯文本文件，实际上它就是一个shell脚本(关于Shell脚本可以参考[这里]())，并且对大小写敏感，里面定义一些变量。重要的变量有三个：

- CC ： 编译器名称
	- `% gcc  main.c` 在makefile中的写法为：`$(CC) main.c`
- CFLAGS ： 编译参数，也就是上面提到的gcc的编译选项。
	- `CFLAGS=-Wall -g`
	- 通常用来指定头文件的位置，常用的是`-I, -g`。
- LDFLAGS ：链接参数，告诉链接器lib的位置
	- 常用的有`-I,-L`

```
CC=gcc
CFLAGS=-Wall -g
clean:
	rm -rf main
```

例如，上面的makefile，有以下几点需要说明：

- 缩进必须用`TAB`

main.o: main.c main.h

这句话的意思是main.o必须由main.c，main.h来生成

`$(CC)main.c`

是shell命令，前面必须加tab

针对上面的例子，我们可以写一个makefile 文件


```
C=gcc
CFLAGS=-g -I./ext/

PROG=p
HDRS=main.h module_1.h ./ext/module_2.h
SRCS=main.c module_1.c ./ext/module_2.c

$(PROG):main.h main.c module_1.h ./ext/module_2.h
	$(CC) -o $(PROG) $(SRCS) $(CFLAGS)

```




## 资料

- [GCC编译参数](https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html)