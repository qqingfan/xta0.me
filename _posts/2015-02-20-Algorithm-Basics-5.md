---
layout: post
title: Algorithm Part 5
mathjax: true
---

## 递推与递归


### 递归的调用过程

- <mark>递归调用是一个后进先出的深搜过程</mark>
    - 调用
        - 使用栈保存调用信息（参数，返回地址）
        - 分配数据区（局部变量）
        - 控制转移给被调函数入口
    - 返回
        - 保存返回信息
        - 退栈，释放数据区
        - 控制转移到上级函数
- 递归树
    - 递归调用可以用树形结构表示
    - 中序遍历

假设有下面的递归函数

```cpp
int f(int n){
    if(n < 2){
        return n+1;
    }else{
        return f(n/2)*f(n/4);
    }
}
```
- <mark>编译器是如何实现递归操作的呢？</mark>

我们知道每次函数调用会开辟新的函数栈空间，递归调用也不例外，只不过编译器为其在栈里插入了一些辅助元素，比如递归返回的函数地址编号`rd`：

![](/assets/images/2015/02/stack1.png)

具体来说，其调用过程如下：

1. 设置一工作栈当前工作记录
    - 保存函数中出现的所有参数和局部变量
        - 函数参数（值参，引用）
        - 局部变量
        - 返回语句标号（t+2个数值）

    ```cpp
    typedef struct elem { // 栈数据元素类型
        int rd; // 返回语句的标号
        Datatypeofp1 p1; // 函数参数
        ...
        Datatypeofpm pm;
        Datatypeofq1 q1; // 局部变量

        Datatypeofqn qn;
    } ELEM;
    ```    
2. 设置 t+2个语句标号
    - `label 0` ：第一个可执行语句
    - `label t+1` ：设在函数体结束处
    - `label i (1<=i<=t)` ： 第`i`个递归返回处
3. 增加非递归入口
    - 入栈：`S.push(t+1，p1, …，pm，q1，…qn`
4. 替换第 `i (i = 1, …, t)`个递归规则
5. 所有递归出口处增加语句：goto label t+1;
6. 标号为t+1的语句的格式
7. 改写循环和嵌套中的递归
8. 优化处理

### 递归树

还是上面例子的递归函数，由于其有返回值，我们可以将其改写成下面的样子：

```cpp
//改写后    
void exmp(int n, int& f) {
    int u1, u2;
    if (n<2){
        f = n+1;
    }else{
        exmp((int)(n/2), u1);
        exmp((int)(n/4), u2);
        f = u1*u2;
    }
}
```
    
上述递归过程的递归树如图所示，可见其实际上是一个深度优先遍历（中序遍历）的过程。

![](/assets/images/2015/02/tree1.png)


### 减而治之的策略

