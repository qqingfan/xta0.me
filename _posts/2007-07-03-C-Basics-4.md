---
title: C Part 4 | Advanced Topics
layout: post
---

## Bitwise Operations

这一节我们研究如何使用位运算，完成加减乘的数学运算。在介绍每种运算之前，先来复习下基本的逻辑运算：

|---|---|---|---|---|---|
|x| y | AND | OR | XNOR(同或) | XOR(异或)
|0| 0 | 0 | 0 | 1 | 0 |
|0| 1 | 0 | 1 | 0 | 1 |
|1| 0 | 0 | 1 | 0 | 1 |
|1| 1 | 1 | 1 | 1 | 0 |

### 四则运算

- 加法

我们先使用真值表分析两个bit相加的几种情况，进而推算出多个bit的加法规则

|---|---|---|---|
|x| y | sum | carry |
|0| 0 | 0 | 0 |
|0| 1 | 1 | 0 |
|1| 0 | 1 | 0 |
|1| 1 | 0 | 1 |

由上面的真值表可以推到看出:

1. `sum = x XOR y`
2. `carry = x AND y`

回想十进制的两位数加法规则，如果个位相加有进位，则十位要累加进位，同样的规则也适用于位运算，我们将上面真值表中加入上一次计算的进位项：

|---|---|:---:|---|---|
|x| y | last carry |sum | carry |
|0| 0 | 0 | 0 | 0 |
|0| 0 | 1 | 1 | 0 |
|0| 1 | 0 | 1 | 0 |
|0| 1 | 1 | 0 | 1 |
|1| 0 | 0 | 1 | 0 |
|1| 0 | 1 | 0 | 1 |
|1| 1 | 0 | 0 | 1 |
|1| 1 | 1 | 0 | 1 |

由上面真值表不难发现，多个bit的叠加是一个循环的过程，即第0为产生的carry带给第1位，第1位的x，y相加后再加上carry，将产生的carry再带给第2位...，以此类推。想想我们如何用程序实现这个过程，首先最容易想到的是将两个数x，y分别转成二进制数，然后按照真值表的规则，逐位相加。但是将一个数拆成二进制这种做法太麻烦，工作量很大，而且计算速度满。实际上要达到同样的效果，也可以这么做，首先将x,y先进行XOR操作，得到各个位上未累加carry项的结果A，然后再令x,y进行AND操作，得到每第一位的carry结果B，接着可以让A累加上每一位的carry，即AB进行XOR操作，但这个操作又会带来新的carry，于是循环这个而操作，直到carry为0

```cpp
int add(int a, int b){
    int sum = 0,carry = 0;
    do{
        sum = a^b;
        carry = (a&b)<<1;
        sum = a;
        carry = b;
    }while(carry > 0)
    
    return sum;
}
```

对于上述代码，`sum`循环累加`carry`的过程有些不好理解，我们以`3+1`为例，看一下这个过程

```
    011         011         001  
XOR 001     AND 001     <<    1
-------     --------    ------- 
    010         001         010  
-------------------------------------（1）

    010         011         010  
XOR 010     AND 010     <<    1
-------     --------    ------- 
    000         010         100  
------------------------------------- (2)

    000         000      
XOR 100     AND 100     
-------     --------    
    100         000     
------------------------------------- (3)
```

1. 第(1)步累加之后carry项为`010`表示在计算第一位时产生了一个carry，需要将其累加到sum的第二上
2. 第(2)步将sum的第二项和carry累加得到`000`，此时又产生了新的carry`010`，因此需要将其加到sum的第三位上
3. 第(3)步将sum的第三项和carry累加得到`100`，此时的carry为0，说明此次相加没有产生新的carry，运算结束

- 减法

有了加法之后，后面的减法和乘法就要简单很多，先看减法，要计算`a+b`可以转化为计算`a+(-b)`，那么如何表示`-b`呢？这个问题在[C语言第二部分中曾提到过]()，在计算机中，有符号数是通过补码进行存储的，补码计算方式为“源码取反+1”, 因此`-b`可以表示为:`~b+1`，`a+b`可以表示为`a+(~b+1)`。理解了这个，减法就很容易实现了

```cpp
int subtract(int a, int b){
　　int subtrahend = add(~b, 1);
　　int sub = add(a, subtrahend);
　　return sub;
}
```
- 乘法

乘法计算也可以转化为加法计算，只需要将被乘数循环累加乘数次即可。考虑到乘数或者被乘数中可能有负数，因此还需要想办法解决符号的问题。这种方式相对简单，但是效率不高，这里讨论另一种手动模拟乘法的方式，假如我们要做`2x3`和`2x5`我们可以像做十进制乘法一样对二进制各位进行乘法运算后求和：

```
    010             010
*   011         *   101  
-------         -------
    010             101
   0100            0000
 000000           10100
-------         -------
 000110           11001
```

观察上面运算可以发现：

1. 令乘数的每一位与被乘数相乘，每乘一次乘数向右移动一位，直到乘数为0
2. 如果乘数的第`n`位为1，只需要将被乘数左移`n`位即可，果乘数的第`n`位为0，这次计算可以跳过

```cpp
int multiply(int a, int b){

　　int x = a < 0 ?  add(~a , 1) : a; //取绝对值
　　int y = b < 0 ? add(~b, 1) : b; //取绝对值

    int sum=0;
    while(y){
        if(y & 0x01){
            sum = add (sum, x);
        }
        x<<1;
        y>>1;
    }
  
　　//计算乘积的符号
    int product = 0;
    if((a^b)<0){
        product = add(~sum,1);
    }
    return product;
}
```

- 除法

简单的除法是不断用被除数减去除数，直到被除数小于除数，此时做减法的次数为商，余数为被除数。同样，除法也需要考虑符号问题

```cpp
int divide(int a, int b){
    int dividend = a < 0 ? add(~a, 1) : a; //取绝对值
    int divisor = b < 0 ? add(~b, 1) : b; //取绝对值
    int remainder = dividend;
    int result = 0;
    while(remainder >= divisor){
        remainder = substract(remainder,divisor);
        result = add(result,1);
    }
    if((a^b)<0){
        result = add(~result,1);
    }
    return result;
}
```


### Hash运算