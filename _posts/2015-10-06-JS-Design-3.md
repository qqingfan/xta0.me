---
layout: post
list_title: 理解Javascript（二）| How Modules work
title: Node.js中的Module
categories: [Javascript]
---

### require & exports

Node.js中使用`require`和`export`来处理module，其调用形式为

```js
//great.js
function greet(){
    consolo.log('greet!')
}
//app.js
require('./greet.js');
greet(); //wrong
```
按照经验，在`require`了`greet.js`之后，就应该可以访问到这个函数，结果却是不可以，其原因在后面会分析，如果想要使用module中的代码需要显式的将其`exports`出来，用的时候需要将其作为函数对象来使用

```js
//great.js
function greet(){
    consolo.log('greet!')
}
module.exports = greet;

//app.js
var greet = require('./greet.js');
greet(); //wrong
```

这个例子可以看出来，`module.exports`返回的是一个函数对象，而Javascript中的函数对象是多种多样的，比如下面代码返回一个"构造函数"

```js
//module2.js
function House(bedrooms, bathrooms, numSqrt){
    this.bedrooms = bedrooms;
    this.bathrooms = bathrooms;
    this.numSqrt = numSqrt;
    this.log = function(){
        console.log("#bedreooms: "+this.bedrooms + " " +
                    "#bathrooms: "+this.bathrooms + " "+
                    "#size: "+ this.numSqrt)
    }
}
module.exports = House;

//app.js
var House = require('./module2')
var house = new House(2,2,100)
house.log()
```

### IIFE

IIFE是(Immediately Invoked Function Expressions)的缩写，形式如下

```javascript
(function(){
    //function body
}());
```
这种函数被定以后立刻自己执行自己，很长一段时间JavaScript以这种形式来封装Module，其思路大概是import这个函数，传入一些参数，这个函数立刻执行并且只局限在自身的scope，例如我们可以用下面这种方式来封装Module中的函数

```javascript
var object = (function(){
    var average = function(myGrades) {
        var total = myGrades.reduce(function(accumulator, item) {
        return accumulator + item;
        }, 0);
        return'Your average grade is ' + total / myGrades.length + '.';
    };
    return {
        name:"Kevin",
        average: average
    }
})();
console.log(object.average([93, 95, 88, 0, 55, 91]))
```
### Require Behind Sence

有了前面的铺垫，下面可以来回答前面的问题，在node.js中`require`和`export`是怎么工作的。还是以上面的代码为例

```js
//module1.js
function greet(){
    consolo.log('greet!')
}
module.exports = greet;

//app.js
var greet = require('./module1.js');
greet(); //wrong
```

接下来从`app.js`的第一句开始，注意JavaScript是门解释型语言，它的`require`并非是一个编译器的预处理符号，而是一个函数，需要被解释器解释执行，可以在`require`处打一个断点，观察Nodejs的执行过程。

```javascript
> var greet = require('./module1');
  greet();

```
断点后，首先进入内部的`require`函数，传入path为当前文件的路径

```javascript
  function require(path) {
    try {
      exports.requireDepth += 1;
      return mod.require(path); //返回mod.require,path是当前文件路径
    } finally {
      exports.requireDepth -= 1;
    }
  }
```

从这个函数的注释中可知，该函数会load`path`文件中所有的module，并返回它们的`exports`成员。这个函数并未做其它事情，而是直接调用了`Module._load`函数，如下

```javascript
// Loads a module at the given file path. Returns that module's
// `exports` property.
Module.prototype.require = function(path) {
  assert(path, 'missing path');
  assert(typeof path === 'string', 'path must be a string');
  return Module._load(path, this, /* isMain */ false);
};

// Check the cache for the requested file.
// 1. If a module already exists in the cache: return its exports object.
// 2. If the module is native: call `NativeModule.require()` with the
//    filename and return the result.
// 3. Otherwise, create a new module for the file and save it to the cache.
//    Then have it load  the file contents before returning its exports
//    object.
Module._load = function(request, parent, isMain) {
    //1. check cache

    //2. check native

    //3. create a new module
    //filename : "xxxx/module1.js"
    //parent: "xxxx/app.js"
    var module = new Module(filename, parent);
    
    //...
}
```
省略掉一些代码，注释上看，这个函数只做三件事，检查缓存中是否有这个module，检查该module是否是NativeModule，所谓NativeModule是Node.js中V8部分的C++代码，显然，这里的module不是NativeModule，于是走到了第三步，创建一个新的JS Module，两个参数分为别待创建Module文件的路径，和当前Module文件的路径。被创建好的`module`其`exports`对象为空，因此不难猜到后面将会去load这个`module`,为`exports`赋值。接下来走到

```javascript
Module.prototype.load = function(filename) {
  //....
  var extension = path.extname(filename) || '.js';
  if (!Module._extensions[extension]) extension = '.js';
  Module._extensions[extension](this, filename);
  this.loaded = true;
  //...
};
```

这个函数中










### More on Require

如果被require的文件过多，可以将他们放到文件夹中，并创建一个`index.js`文件用来索引其它被`require`的文件。假设文件结构如下

```
├── app.js
├── greet
│   ├── English.js
│   ├── Spanish.js
│   ├── config.json
│   └── index.js
```

在`app.js`中可以通过`require './greet'`来间接应用`English.js`和`Spanish.js`两个Module，`require './greet'`会调用默认`require './greet/index.js'`：

```javascript
//index.js
var e = require ('./English')
var s = require ('./Spanish')

module.exports = {
    english:e,
    spanish:s
}

//app.js
var greet = require('./greet')
greet.english();
greet.spanish();

```

### Module Patterns