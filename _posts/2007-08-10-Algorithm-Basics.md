---
layout: post
title: 算法思想
---


### 枚举

- 基于已有知识进行**答案猜测**的一种问题求解策略
    - 例如求解小于N的最大素数。求解策略为
        - 2是素数, 记为PRIM0
        - 根据PRIM0，PRIM1, …, PRIMk, 寻找比PRIMk大的最小素数PRIMk+1
        - 如果PRIMk+1大于N, 则PRIMk是我们需要找的素数,否则继续寻找
- 核心思想是**猜和测**，从可能的集合中一 一列举各元素
    -  根据所知道的知识, 给一个猜测的答案，比如2是素数
- 枚举算法
    - 对问题可能解集合的每一项
    - 根据问题给定的检验条件判定哪些是成立的
    - 使条件成立的即是问题的解
- 三个关键问题
    - 给出解空间，建立简洁的数学模型
        - 可能情况是什么
        - 模型中变量数尽可能少，他们之间相互独立
    - 减少搜索的空间
        - 利用知识缩小模型中各变量的取值范围, 避免不必要的计算
        - 减少代码中循环体执行次数
            - 除2之外, 只有奇数才可能是素数,`{2,2*i+1|1<=i, 2*i+1<n}`
    - 采用合适的搜索顺序
        - 搜索空间的遍历顺序要与模型中条件表达式一致
            - 对{2,2*i+1|1<=i, 2*i+1<n}按照从小到大的顺序

- `百鸡百钱`问题

> 鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一.百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何 —— 张丘建《算经》

先分析条件：

1. `X`, `Y`, `Z`分别代表买公鸡, 母鸡和小鸡的只数
2. `5X+3Y+Z/3=100`
3. `Z%3==0`

```cpp
for(int x=0; x<=100; x++){
    for(int y=0; y<=100-x; y++){
        z = 100-x-y;
        if(z%3 == 0){
            if(5*x+3*y+z/3==100){
                //x,y,z is the solution
            }
        }
    }
}
```

### 递归

- 递归 — 某个函数直接或间接的调用自身的问题求解过程
    - 大问题划分成许多相同性质的子问题的求解   
    - 而小问题的求解过程可以很容易的求出
    - 这些子问题的解就构成里原问题的解

- 总体思想
    - 待求解问题的解 -> 输入变量`x`的函数`f(x)`
    - 通过寻找函数`g(x)`, 使得`f(x) = g(f(x-1))`
    - 且已知`f(0)`的值, 就可以通过`f(0)`和`g( )`求出`f(x)`的值
- 推广
    - 扩展到多个输入变量`x, y, z`等, `x-1`也可以推广到 `x - x1`,只要递归朝着 “出口” 的方向即可

- 递归与枚举的区别
    - 枚举:
        - 把一个问题划分成一组子问题, 依次对这些子问题求解
        - 子问题之间是横向的, 同类的关系
    - 递归:
        - 把一个问题逐级分解成子问题
        - 子问题与原问题之间是纵向的, 同类的关系
    - 语法形式上: 在一个函数的运行过程中, 调用这个函数自己
        - 直接调用: 在`fun()`中直接执行`fun()`
        - 间接调用: 在`fun1()`中执行`fun2()`; 在`fun2()`中又执行`fun1()`

- 三个要点
    - **递归式**:如何将原问题划分成子问题
    - **递归出口**: 递归终止的条件, 即最小子问题的求解,可以允许多个出口
    - **边界函数**:问题规模变化的函数, 它保证递归的规模向出口条件靠拢

- 递归解决问题的关键
    - 找出递推公式
    - 找到递归终止条件
- **注意事项**: 由于函数的局部变量是存在栈上的如果有体积大的局部变量, 比如数组,而递归层次可能很深的情况下, 也许会导致栈溢出可以考虑使用全局数组或动态分配数组

- 常见的递归问题
    - 迷宫求解
        - 自相似性：每一步走的探测方式相同
        - 通过枚举方式找到从起点到终点的路径，朝一个方向走下去
            - 如果走不通，换个方向
            - 四个方向都不通，回到上一步的地方换方向走
            - 以此类推
