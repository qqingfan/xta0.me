---
layout: post
title: 几种算法的基本思想
---

## 枚举

- 基于已有知识进行**答案猜测**的一种问题求解策略
    - 例如求解小于N的最大素数。求解策略为
        - 2是素数, 记为PRIM0
        - 根据PRIM0，PRIM1, …, PRIMk, 寻找比PRIMk大的最小素数PRIMk+1
        - 如果PRIMk+1大于N, 则PRIMk是我们需要找的素数,否则继续寻找
- 核心思想是**猜和测**，从可能的集合中一 一列举各元素
    -  根据所知道的知识, 给一个猜测的答案，比如2是素数
- 枚举算法
    - 对问题可能解集合的每一项
    - 根据问题给定的检验条件判定哪些是成立的
    - 使条件成立的即是问题的解
- 三个关键问题
    - 给出解空间，建立简洁的数学模型
        - 可能情况是什么
        - 模型中变量数尽可能少，他们之间相互独立
    - 减少搜索的空间
        - 利用知识缩小模型中各变量的取值范围, 避免不必要的计算
        - 减少代码中循环体执行次数
            - 除2之外, 只有奇数才可能是素数,`{2,2*i+1|1<=i, 2*i+1<n}`
    - 采用合适的搜索顺序
        - 搜索空间的遍历顺序要与模型中条件表达式一致
            - 对{2,2*i+1|1<=i, 2*i+1<n}按照从小到大的顺序

- `百鸡百钱`问题

> 鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一.百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何 —— 张丘建《算经》

先分析条件：

1. `X`, `Y`, `Z`分别代表买公鸡, 母鸡和小鸡的只数
2. `5X+3Y+Z/3=100`
3. `Z%3==0`

```cpp
for(int x=0; x<=100; x++){
    for(int y=0; y<=100-x; y++){
        z = 100-x-y;
        if(z%3 == 0){
            if(5*x+3*y+z/3==100){
                //x,y,z is the solution
            }
        }
    }
}
```

## 递归

- 递归 — 某个函数直接或间接的调用自身的问题求解过程
    - 大问题划分成许多相同性质的子问题的求解   
    - 而小问题的求解过程可以很容易的求出
    - 这些子问题的解就构成里原问题的解

- 总体思想
    - 待求解问题的解 -> 输入变量`x`的函数`f(x)`
    - 通过寻找函数`g(x)`, 使得`f(x) = g(f(x-1))`
    - 且已知`f(0)`的值, 就可以通过`f(0)`和`g( )`求出`f(x)`的值
- 推广
    - 扩展到多个输入变量`x, y, z`等, `x-1`也可以推广到 `x - x1`,只要递归朝着 “出口” 的方向即可

- 递归与枚举的区别
    - 枚举:
        - 把一个问题划分成一组子问题, 依次对这些子问题求解
        - 子问题之间是横向的, 同类的关系
    - 递归:
        - 把一个问题逐级分解成子问题
        - 子问题与原问题之间是纵向的, 同类的关系
    - 语法形式上: 在一个函数的运行过程中, 调用这个函数自己
        - 直接调用: 在`fun()`中直接执行`fun()`
        - 间接调用: 在`fun1()`中执行`fun2()`; 在`fun2()`中又执行`fun1()`

- 三个要点
    - **递归式**:如何将原问题划分成子问题
    - **递归出口**: 递归终止的条件, 即最小子问题的求解,可以允许多个出口
    - **边界函数**:问题规模变化的函数, 它保证递归的规模向出口条件靠拢

- 递归解决问题的关键
    - 找出递推公式
    - 找到递归终止条件
- **注意事项**: 由于函数的局部变量是存在栈上的如果有体积大的局部变量, 比如数组,而递归层次可能很深的情况下, 也许会导致栈溢出可以考虑使用全局数组或动态分配数组

- 常见的递归问题
    - <mark>迷宫求解</mark>
        - 自相似性：每一步走的探测方式相同
        - 通过<mark>枚举+递归</mark>方式找到从起点到终点的路径，Search过程如下
            - 朝一个方向走下去，如果走不通，换个方向
            - 四个方向都不通，回到上一步的地方换方向走
            - 以此类推，直到终点
        - 描述迷宫
            - 使用二维数组描述行列
            - 搜索过程中，用另外一个二维数组标记各自是否已经走过了
            - 其它变量
                - `minstep`,起点到终点的最少路径数，初始化值为int_max
                - `w,h`，迷宫的宽高
        - 枚举行走方向
            - 另`(x,y)`表示行走步长，每步有上下左右四中可能走法，因此会产生8个值，定义一个`int[4][2]`存储可能情况
                - `int to[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}`
                - 枚举向上下左右走

                ```c
                for(int i=0;i<4;++i){
                    int x = now_x + to[i][0];
                    int y = now_y + to[i][1];
                    //新的点(x,y)
                    int direction = i; //0，1，2，分别表示右，向上，向左，向下
                }
                ```
        - 判断当前点`(x,y)`是否有效
            - T1:在边界之内:`(x>-1) && (x<W+2) && (y>-1) && (y<h+2)`
            - T2:该位置不曾走过:`mark[y][x] = false`
            - T3:到达终点：`(x==end_x)&&(y==end_y)&&(board[y][x]=='x')
            - `(x,y)`有效的条件是`T1&&(T2||T3)`    
        - 构造递归函数
        
        ```c
        //now_x,now_y当前位置
        //end_x, end_y结束位置
        //step已经走过的路径数目
        //f从上一步走到(now_x,now_y)时的方向
        void search(int now_x, int now_y, int end_x, int end_y,int step, int f){
            //step0: 检查递归条件
            //当前路径数目大于minstep，说明这条路径不是最优路径
            if(step > minstep) 
                return;
            if(now_x == end_x && now_y == end_y){//到达终点
                //如果这条路径的step比minstep小，更新最小路径数
                if(minstep>step) {
                    minstep = step;
                    return;
                }
            }
            //step1：枚举下一步方向
            for(int i=0;i<4;++i){
                int x = now_x + to[i][0];
                int y = now_y + to[i][1];
                //step3: 检查新的点(x,y)的合法性
                if(T1&&T2||T3){
                    mark[y][x] = true; //标记该位置有效
                    if(f == i){//上一步方向和当前方向相同
                        //递归
                        search(x,y,end_x,end_y,step,i);
                    }else{//否则尝试新路径，step+1
                        search(x,y,end_x,end_y,step+1,i);
                    }
                    //所有递归完成后，发现此路不通，则将走过的标记清空
                    mark[k][x]=false;

                }

            }
        }
        ```

## 动态规划

1. 将原问题分解为子问题
    - 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题解决，原问题即解决
    - 子问题的解可以缓存，所以每个子问题只需要求解一次

2. 确定状态
    - 将和子问题相关的各个变量的一组取值，称之为一个`状态`，一个`状态`对应于一个或多个子问题，所谓某个`状态`下的`值`，就是这个状态所对应的子问题的`解`
    - 所有`状态`的集合，构成问题的`状态空间`。状态空间的大小解解决问题的时间复杂度直接相关。整个问题的时间复杂度是<mark>状态数目乘以每个状态所需要的时间</mark>
    - 经常碰到的情况是，K个整型变量能够成一个状态。如果这个K个整型变量的取值范围分别是`N1,N2,...,Nk`，那么，我们就可以用一个K维数组`array[N1][N2]...[Nk]`来存储各个状态的`值`。这个`值`未必是一个整数或浮点数，也可以是一个复杂的数据结构
3. 确定一些初始状态（边界状态）的值
4. 确定状态转移方程
    - 找到不同状态之间如何迁移-即如何从一个或多个值已知的状态，求出另一个状态的值。状态的迁移可以用递推公式表示，递推公式也可被称作<mark>状态转移方程</mark>

- 递归到动归的一般转化方法
    - 递归函数有n个参数，就定义一个n为数组，数组的下标是递归函数参数的去只范围，数组的元素值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程

- 能用动规解决问题的特点
    1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质
    2. 无后效性。当前的若干状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前的状态无关


