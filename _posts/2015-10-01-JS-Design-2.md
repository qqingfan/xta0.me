---
layout: post
list_title: 理解Javascript（二）| OOP
title: 面向对象设计
categories: [Javascript]
---
### Object

JS中构造Object的方式有很多种，比如使用Object Literal

```js
var person = {
    firstname: "John",
    lastname: 'Doe',
    greet: function(){
        console.log('Hello' + this.firstname + ' ' + this.lastname)
    }
};
person.greet();
```

也可以使用所谓的"构造函数"，通常所说的造函数是定义在某个类中的，由于JavaScript没有类的概念，因此使用了一种很别扭的函数来模拟构造函数

```javascript
function Person(firstname, lastname){
    this.firstname = firstname;
    this.lastname = lastname;
}

var john = new Person("John","Doe");
```

有了构造函数就可以使用`new`来创建object，`new`的作用如下
1. 创建一个空object
2. 创建`this`指向这个空object
3. 在构造函数最后增加一行`return this` 
4. 为空object增加一个成员`__proto__`

另一种创建Object的方法是使用`Object.create(obj)`，这种方法是将`obj`作为Prototype来构造新的对象

```javascript
var person = {
    firstname: "",
    lastname: "",
    greet: function(){
        return this.firstname + ' ' + this.lastname;
    }
}
var john = Object.create(person)
john.firstname="John"
john.lastname="Doe"
console.log(john.greet())
console.log(john.__proto__ == person) //true
```

上述例子中`john`的Prototype对象为`person`，因此它也具有`person`的一系列属性。更夸张的是，`john`同样也可以作为Prototype来继续构造其它对象

```javascript
var jane = Object.create(john);
jane.firstname = "Jane"
jane.lastname = "Doe"
console.log(jane.greet()); //Jane Doe
```

### Prototype

Prototype是另一个比较令人困惑的设计，如果想要给上面的`Person`函数对象增加一个成员`greet`的方法，又不想修改`Person`函数，则需要使用Prototype

```javascript
Person.prototype.greet = function(){
     console.log('Hello' + this.firstname + ' ' + this.lastname);
}
var john = new Person("John","Doe")
john.greet();
```
实际上，每个构造函对象数有一个成员叫做`prototype`，我们可以看看这个Prototype是什么

```javascript
console.log(Person.prototype);
//Person { greet: [Function] }
```
看起来它是一个对象，这个对象时怎么产生的，暂时还不知道，让人困惑的是这个`prototype`对象不仅可以被Person使用，还可以被其它类使用:

```javascript
function Animal(name){
    this.name = name;
}
//set prototype to Animal
Animal.prototype = Person.prototype;
var dog = new Animal("Pluto",3);
dog.greet(); //Hello undefined undefined
```
将`Person`的`prototype`赋给了`Animal`，则`dog`可以调用`greet()`方法，由于`dog`并没有`firstname`和`lastname`，因此输出`undefined`。

猜想这个设计的初衷是为了模拟"继承"机制，通过让多个类共享Prototype来实现对公共API的抽象。对于不同的对象，如果他们share了同一个Prototype中的API，那么可以认为它们有共同的"父类"。但是现在看来，这种机制更像是`Interface`或者`Protocol`，而非继承。

上面例子中，`Animal`虽然可以共享`prototype`对象，但是这个`Prototype`对象还是属于`Person`的。

```javascript
console.log(Person.prototype.constructor); //[Function: Person]
console.log(Animal.prototype.constructor); //[Function: Person]
Person.prototype.constructor === Person; // true
```
咋一看，这又是一个让人无比困惑的设计，`constructor`是什么东西，为什么它还要指回到`Person`？看起来像是这为了解决一个bug而引出的另一个bug。

另外，`prototype`对象不仅属于`Person`和`Animal`中，被它们构造出来的对象也可以访问

```javascript
console.log(tao.__proto__ === Person.prototype ） // true)
console.log(tao.__proto__ == dog.__proto__) //true
```
是不是感觉有点乱了，我们可以画一个三者的关系图

<img class="md-img-center" src="/assets/images/2015/10/js-2.png">

看到这里我们似乎可以感受到，<mark>在JavaScript中object可以表达一切，任何模式都是object之间的各种组合</mark>，由于没有类型系统的约束，使得这门语言中很多概念是模糊的，比如，`john`是一个object，它也可以是Prototype；`Person`既是一个"构造函数"，却也是一个普通函数，可以被正常调用，而函数本身也是一个对象。这些概念上的混淆使得JavaScript变得极为灵活，却也造成了很多困惑。

> 有的时候一门语言设计的太灵活并不一定是一件好事。


### Prototype Chain

回到上面`dog`和`john`的例子，我们用`Prototype`使`dog`和`john`都具有了`greet`方法

<img class="md-img-center" src="/assets/images/2015/10/js-3.png">

上面的结构更像是`dog`和`john`共享了某种Interface，果我们换一种写法

```javascript
function Parent(relation){
    this.relation = relation
    this.greet = function(){
        console.log("I am your: "+relation)
    }
}
function Person(firstname, lastname){
    this.firstname = firstname;
    this.lastname = lastname;
}
Person.prototype = new Parent("Father")
var john = new Person("John","Doe")
john.greet()
```
这种写法和之前其实并无本质区别，都是改变`Person.prototype`，但这种写法更像是继承关系，当`join`调用`greet`之后，会现在`Person`中寻找，发现没有，然后在`Person.prototype`中寻找。而`Person.prototype`指向`Parent`，感觉上是在`Person`的”父类“中寻找。因此这种写法相当于通过`prototype`对象将两个对象链接起来了，如下图所示

<img class="md-img-center" src="/assets/images/2015/10/js-1.png">

JavaScript称这种方式的调用为**Prototype Chain**。具体来说，当object调用一个方法，首先在自己的构造函数对象中寻找，找不到则在`__proto__`中寻找，这个`__proto__`对象也有自己的`__proto__`会一直向上找，直到`__proto__`对象为空。

```javascript
Array arr = new Array()
arr. hasOwnProperty('length') //true
//hasOwnProperty这个方法定义在 Array.__proto__.__proto__中
```

但是奇怪的事情又发生了，假设我们再增加一层

```javascript
function GrandParent(relation){
    this.relation = relation
    this.greet = function(){
        console.log("I am your: "+relation)
    }
}
function Parent(relation){
    this.relation = relation
}
function Person(firstname, lastname){
    this.firstname = firstname;
    this.lastname = lastname;
}
Person.prototype = new Parent("Father")
Parent.prototype = new GrandParent("Grandpa")
var john = new Person("John","Doe")
john.greet()
```


### 函数的重载

如果`Person`自己内部定义了`greet`函数，它的Prototype上还有一个函数：

```javascript
function Person(firstname, lastname){
    this.firstname = firstname;
    this.lastname = lastname;
    this.greet = function(msg){
        console.log(msg);
    }
}
Person.prototype.greet = function(){
     console.log('Hello' + this.firstname + ' ' + this.lastname);
}
tao.greet();
```
这时如果调用`greet`函数会发生什么？

```javascript
var Person = require('./module2');
var tao = new Person("Tao","Xu");
tao.greet(); //undefined
tao.greet("abc"); 
```
按照经验，两个`greet`的函数签名不同，应该会各自调用不同版本的函数，结果第一个函数竟然返回`undefined`，也就是说找不到`greet()`这个函数，





### Call/Apply/Bind

```javascript
var Person = function(firstName,lastName){
	this.firstName = firstName //this refers to the Person object
	this.lastName = lastName
}

var tom = new Person("Tom","Xu") 
console.log ( tom.firstName ); 
console.log ( tom.lastName );
```

共享构造函数:可以使用`apply`,`call`传递`this`实现共享构造函数

```javascript
function Car(make, model, year){
    this.make  = make;
    this.model = model;
    this.year  = year;
    this.numWheels = 4;
}

function MotoCycle(make, model, year){
    //using call
    //Car.call(this, make, model, year)
    //using apply
    //Car.apply(this, [make,model,year]);
    Car.apply(this,arguments)
    this.numWheels = 2;
}

var motocycle = new MotoCycle("a","b","2011")
console.log (motocycle.numWheels) //2
```










