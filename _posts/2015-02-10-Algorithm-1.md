---
layout: post
title: Algorithm Part 1
mathjax: true
---

今天加上接下来的几天，我们来聊一聊算法，具体内容来自下面三门课的笔记以及一些个人的总结

- [算法设计与分析](https://www.coursera.org/learn/algorithms)
- [算法基础](https://www.coursera.org/learn/suanfa-jichu)
- [Algorithms(stanford)](https://www.coursera.org/specializations/algorithms)

## 算法

### 算法特性

- 通用性
	- 对参数化输入进行问题求解
	- 保证计算结果的正确性
- 有效性
	- 算法是有限条指令组成的指令序列
	- 即由一系列具体步骤组成  
- 确定性
	- 算法描述中的下一步应该执行的步骤必须明确
- 有穷性
	- 算法的执行必须在有限步内结束
	- 换句话说，算法不能含有死循环 

### 算法分类

- 穷举法
	- 顺序查找k值
- 回溯，搜索
	- 八皇后，树和图的遍历
- 递归分治
	- 二分法找k值，快速排序，归并排序
- 贪心法
	- Huffman编码树，最短路径Dijkstra，最小生成树prim算法
- 动态规划
	- 最短路Floyd算法   

### 算法的伪码表示

- 基本符号

```
赋值语句：<- / = 
分支语句：if...then...[else...]
循环语句：while, for, repeat until
转向语句：goto
输出语句：return
调用：直接写过程的名字
注释：//...
```

- 求解最大公约数

```
//输入：非负整数m,n，其中m与n不全为0
//输出：m与n的最大公约数

Euclid(m,n){
	while m>0 do
		r <- n mod m
		n <- m
		m <- r
	return n
}
```


## 算法设计的几个例子

### 背包问题


### 算法分析的一般思考方式

- 建模
    - 优化目标
    - 约束条件

## 排序问题的计算复杂度

|算法|最坏情况|平均情况|
|---|-------|------|
|插入排序| `O(n^2)`| `O(n^2)`|
|冒泡排序| `O(n^2)`| `O(n^2)`|
|快速排序| `O(n^2)`| `O(nlog(n))`|
|堆排序| `O(nlogn)`| `O(nlog(n))`|
|二分归并排序| `O(nlog(n))`| `O(nlog(n))`|

排序算法以元素的比较作为基本运算，是否存在更优化算法，有待研究


## 几个NP-Hard问题

### 货郎问题

### 0-1背包问题

### 双机调度问题


### NP-Hard问题

- 类似问题数千个，大量存在与各个应用领域
- 至今没有找到有效算法
    - 现有算法的运行时间是输入规模的指数或更高阶的函数
- 至今没有人能证明对于这类问题不存在多项式时间的算法
- 从是否存在多项式时间算法的角度看，这些问题彼此是等价的。<mark>这些问题的难度处于有效计算的边界</mark>

