---
layout: post
title: Data Structure Part 1
---

##什么是数据结构

- 结构：实体+关系
- 数据结构：
	- **逻辑**: 按照逻辑关系组织起来的一批数据
	- **存储**: 按一定能的存储方法把它存储在计算机中
	- **运算**: 在这些数据上定义了一个运算集合

### 线性结构

- 线性表（表，栈，队列，串）

### 非线性结构

- 树（二叉树，Huffman树，二叉检索树等）
- 图（有向图，无向图）

### 数据存储结构

- 逻辑结构到物理存储空间的映射
- 四类：顺序，链接，索引，散列

### 抽象数据类型

- 简称ADT(Abstract Data Type)
	- 定义了一组运算的数学模型
	- 与物理存储结构无关
	- 使软件建立在数据之上（面向对象） ，例如Stack，Tree这种数据结构  

- 抽象数据结构二元组`<数据对象D，数据操作P>`
- 先定义逻辑结构，再定义运算
	- `逻辑结构`：数据对象及其关系
	- `运算`：数据操作->函数 

	
## 算法的特性及分类

### 算法特性

- 通用性
	- 对参数化输入进行问题求解
	- 保证计算结果的正确性

- 有效性
	- 算法是有限条指令组成的指令序列
	- 即由一系列具体步骤组成  

- 确定性
	- 算法描述中的下一步应该执行的步骤必须明确

- 有穷性
	- 算法的执行必须在有限步内结束
	- 换句话说，算法不能含有死循环 

### 算法分类

- 穷举法
	- 顺序查找k值

- 回溯，搜索
	- 八皇后，树和图的遍历

- 递归分治
	- 二分法找k值，快速排序，归并排序

- 贪心法
	- Huffman编码树，最短路径Dijkstra，最小生成树prim算法

- 动态规划
	- 最短路Floyd算法      

	
### 算法度量

- 算法渐进分析
```
f(n) = n^2 + 100n + log10(n) + 1000
```
- 当数据规模n逐步增大时，f(n)的增长趋势
- 当n增大到一定值后，计算公式中影响最大的就是n的幂次最高的项
 - 其它的常数项和低幂次项都可以忽略

- <mark>大O表示法</mark>
	- 函数`f`，`g`定义域为自然数，值域为非负实数集
	- 定义：如果存在正数`c`和`n0`，使得任意`n>=n0`，都有`f(n)< cg(n)`
		- 称f(n)在O(g(n))的集合中，简称f(n)是O(g(n))的，或者f(n) = O(g(n))
		- 大O表示法：表达函数增长率的上限
			- 一个函数增长率的上限可能不止一个，尽量找到最紧的
		- 当上下限相同时可以用θ表示法 

![](d-1-1.png)

- 大O表示法的单位时间 
	- 简单的布尔或算术运算:O(1)
	- 简单I/O
		- 函数的输入/输出
			- 例如，从数组读取数据等操作 
		- 不包括文件的I/O
	- 函数的返回

- 大O表示法的运算法则
	- 加法规则: f1(n) + f2(n) = O(max(f1(n),f2(n)))
		- 顺序结构，if结构，switch结构
	
	- 乘法规则: f1(n)*f2(n) = O(f1(n)*f2(n))
		- for，while，do-while结构
		
		```c
		
		for(int i=0; j<n; i++){
			for(j=i;j<n;j++)
			{ k++; }
		}
		
		//复杂度为O(n^2)
		```
		
- 大Ω表示法
	- 定义：如果存在正数c和n0，使得对所有n>=n0，都有**f(n) >= cg(n)**，则称f(n)在集合Ω(g(n))中，或简称f(n)是Ω(g(n))的，或f(n) =  Ω(g(n))。主要用于确认算法时间复杂度的下界
	- 与大O表示法唯一的区别在于不等式的方向而已

![](d-1-2.png)

- 大θ表示法
	- 当上，下限相同时则可以用theta表示法 
	- 定义：如果一个函数在集合O(g(n))中又在集合 Ω(g(n))中，则称其为theta(g(n))
		- 也即，当上下限相同时可以用大θ表示法
		- 存在常数c1,c2，以及整数n0，使得对任意的正整数n>n0，有下列不等式成立：c1g(n)<= f(n) <= c2g(n)  

![](d-1-3.png)

- 增长率函数曲线
<math>
    <msubsup><mi>2</mi> <mi></mi> <mi>n</mi></msubsup>
    <mo>></mo>
    <msubsup><mi>n</mi> <mi></mi> <mi>2</mi></msubsup>
    <mo>></mo>
	<msubsup><mi>nlog</mi> <mi>2</mi> <mi>n</mi></msubsup> 
	 <mo>></mo>
	 <msubsup><mi>n</mi> <mi></mi> <mi></mi></msubsup>
	 <mo>></mo>
	 <msubsup><mi>log</mi> <mi>2</mi> <mi>n</mi></msubsup>     
</math>

- 问题控件 vs 时间开销，衡量一个算法要考虑数据集最好，最坏以及平均三种情况的时间复杂度
	- 顺序找K值：顺序从一个规模为n的一维数组中找出一个给定的k值
		- 最佳情况:数组中第一个元素就是k，那么只要检测一个元素，复杂度为O(1)
		- 最坏情况:k是数组中最后一个元素，那么需要遍历所有元素，复杂度为O(n)
		- 平均情况:k值出现在n个位置上的概率都是1/n，平均代价O(n) = (1+2+3+..+n)/n = (n+1)/2 
	- 二分法找k值，对于已排序的线性表 
	
- 时间/空间权衡
	- 数据结构
		- 一定的控件来存储它的每一个数据项
		- 一定的时间来执行单个基本操作
	
	- 代价和效益
		- 空间和时间的限制
		- 软件工程

	- 增大空间开销可能改善算法的时间开销
	- 节省空间，会带来时间的增大   	  

	


### 顺序表

#### 基本概念

- 也称向量，采用定长的一维数组存储结构
- 主要特性
	- 元素类型相同
	- 元素顺序的存储在连续的存储空间中，每个元素有唯一的索引值
	- 使用常数作为向量长度

- 数组存储
- 读写元素很方便，通过下标即可指定位置
	- 只要确定了首地址，线性表中任意数据元素都可以随机存取

#### 顺序表类定义

```cpp

class MyList:public List<T>{
	
	private:
		T* list;
		int maxSize;
		int position;
	public:
		MyList(const int size){
			maxSize = size;
			list = new T[maxSize];
			position = 0;
		}
		~MyList(){
			delete []list;
			list = nullptr;
		}
		void clear(){
			delete []list;
			list = nullptr;
			position = 0;
			list = new T[maxSize];
		}
		
		int length(){
			return postion;
		}
		
		bool append(const T value){
			if(position == maxSize){
				return false;
			}
			else{
				list[postion] = value;
				position ++;
				return true;
			}
			
		}
		bool insert(const int p, const T value){
		
		}
		
		bool delete(const int p){
		
		}
		
		bool setValue(const int p, const T value){
		
		}
		
		bool getValue(const int p, T& value){
		
		}
		
		bool getPos(int &p, const T value){
		
		}
}

```


#### 顺序表插入删除运算的算法分析  
- 表中元素的移动
	- 插入：移动n-i
	- 删除：移动n-i-1

- 时间复杂度为O(n)
- 优点：
	- 不需要附加空间
	- 随机存取任意元素

- 缺点：
	- 一开始就要分配足够大的一片连续内存空间，很难估计所需空间的大小
	- 更新操作代价巨大，插入删除操作移动大量元素，效率较低  


### 链表

#### 基本概念

- 通过指针把它的一串存储节点连接成一个链
- 存储节点由两部分组成
	- 数据域(data) + 指针域（后继地址,next） 

#### 分类

- 单链，双链，循环链

#### 单链表
- 带头结点的单链表
	- 整个单链表：head
	- 第一个节点：head->next, head != NULL;
	- 空表判断：head->next == NULL; 
	- 当前节点：fence->next(curr隐含)

#### 接口定义

```cpp

#import "Interface.h"
template<class T>
struct LinkedNode:public Interface<T>{
    
private:
    T  _value;
    LinkedNode<T>* _next;
    LinkedNode<T>* _head;
    LinkedNode<T>* _tail;
    
public:
    LinkedNode(T value){
        _value = value;
        _next = nullptr;
    }
    ~LinkedNode(){}
    void clear();
    int lenght();
    bool append(const T value);
    bool insert(const int p, const T value);
    bool remove(const int p);
    bool setValue(const int p, const T value);
    bool getValue(const int p, T& value);
    bool getPos(int &p, const T value);
};

```
#### 单链表插入

- 创建新节点
- 新节点指向右边的节点
- 左边节点指向新节点

#### 单链表的删除

- 用p指向元素x的节点的前驱节点
- 删除元素x的节点
- 释放x占据的空间

#### 单链表上的运算分析

- 对一个节点的操作，必须先找到它
- 找单链表中的任一节点，必须从第一个点开始
- 单链表操作的时间复杂度为`O(n)`
	- 定位：`O(n)`
	- 插入：`O(n) + O(1)`
	- 删除：`O(n) + O(1)`

#### 双向链表

- 和单链表相比多一个前驱节点：

```cp



```


#### 循环链表	

- 将单链表或者双链表的头尾节点连起来就是一个循环链表
- 不增加额外存储花销，却给操作里带来方便
	- 从循环链表中任一节点出发，都能访问到链表中的其它节点
	- 循环链判断结束的方法
		- 计数
		- tail -> next = head  

#### 链表的边界条件

- 几个特殊点处理
	- 头指针处理
	- 非循环链表尾节点的指针为null
	- 循环链表尾节点指向头结点

- 链表处理
	- 空链表的特殊处理
	- 插入或删除节点时指针勾链的顺序
	- 指针移动的正确性
		- 插入
		- 查找或遍历   


### 顺序表和链表的比较

#### 顺序表
- 没有使用指针，不用花费额外开销
- 线性表元素的读访问非常便利
- 插入，删除运算时间代价O(n)，查找则可以常数时间完成
- 预先申请固定长度的连续空间
- 如果整个数组元素很慢，则没有结构性存储开销
- 适合静态数据结构
- 不适合：
	- 经常插入删除时，不宜使用顺序表
	- 线性表的最大长度也是一个重要因素 

#### 链表
- 无需事先了解线性表长度
- 允许线性表动态变化
- 能够适应经常插入删除内部元素的情况
- 插入，删除运算时间代价O(1)，但找第i个元素运算时间代价O(n)
- 存储利用指针，动态的按照需要为表中的新元素分配存储空间
- 每个元素都有结构性存储开销
- 适合动态数据结构
- 不适合：
	- 当读操作比插入删除操作频率大时，不用用链表
	- 当指针的存储开销和整个节点内容所占空间相比较大时，应谨慎选择 


#### 顺序表和链表存储密度

n表示线性表中当前元素的数目
p表示指针的存储单元大小(通常为4 bytes)
e表示数据元素的存储单元大小
d表示可以再数组中存储的线性元素的最大数目

- 空间需求
	- 顺序表的控件需求为 d*e
	- 链表的空间需求未n(p+e)

- n的临界值，即 n>d*e/(p+e)
	- n越大，顺序表的空间效率就更高
	- 如果p=e， 则临界值为 n = d/2  



#### 顺序表和链表的选择

- 顺序表
	- 节点数目大概可以估计
	- 线性表中节点比较稳定（插入删除少）
	- n > de/(p+e)

- 链表
	- 节点数目无法预知
	- 线性表中节点动态变化（插入删除多）
	- n < de/(p+e)  


### 约瑟夫问题

- 算法+数据结构 = 程序
- 约瑟夫问题：
	- 背景：约瑟夫是一名犹太人，在罗马人占领桥塔帕特之后，39名犹太人与约瑟夫及他的朋友躲到一个山洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式 
	- 问题描述：对于任意给定的n,s和m，求按出列次序得到的人员序列
		- n：参加游戏的人数
		- s: 开始的人
		- m：间隔

### 栈

- 主要操作：push，pop
- 应用：
	- 表达式求值
	- 消除递归
	- 深度优先搜索

- 抽象数据类型：


```cpp

template<class T>
class Stack{
public:
	void clear();
	bool push(const T item);
	bool pop(T& item);
	bool top(T& item);
	bool isEmpty();
	bool isFull();
};

```

- 思考：
	- 若入栈顺序为1，2，3，4，出栈顺序有哪些？
	- 从初始输入序列1，2，...，n，希望找一个栈得到输入序列p1,p2,p3,...,pn(它们是1，2，...，n的一种序列)若存在下标i,j,k，满足i<j<k 同时pj<pk<pi，则输入是否合法？

- 栈的实现方式：
	- 顺序栈（Array-based Stack）
		- 使用向量实现，本质上是顺序表的简化版
		- 关键是确定哪一端作为栈顶
		- 上溢，下溢问题

	- 链式栈（Linked Stack）
		- 使用单链表方式存储，其中指针的方向是从栈顶向下链接  

### 顺序栈和链式栈的比较

- 时间效率
	- 所有操作都只需要常数时间
	- 顺序栈和链式栈在时间效率上难分伯仲

- 空间效率
	- 顺序栈需要说明一个固定长度
	- 链式栈长度可变，但增加结构开销  

- 实际应用中，顺序栈比链式栈用的更广泛
	- 顺序栈容易根据栈顶位置，进行相对位移，快速定位并读取栈内部的元素
	- 顺序栈读取内部元素时间为O(1),链式栈需要沿着栈顶指针游走，显然慢些，读取第k个元素需要的时间为O(k)。
	- 一般来说，栈不允许“读取内部元素”，只能在栈顶操作 

### 栈的应用

- 栈的特点：后进先出
- 常用来处理具有递归结构的数据结构
	- 深度优先搜索
	- 表达式求值
	- 子程序/函数调用的管理
	- 消除递归

	
#### 计算表达式的值

- 表达式的递归定义
	- 基本符号集合：{0，1，2，3，... ，9，+，-，*，/,(,)}
	- 语法成分集合:{<表达式>,<项>,<因子>,<常数>,<数字>}

- 中缀表达式 23+(34*45)/(5+6+7)

	- 中缀表达式与后缀表达式
		- 中缀表达符合人类对数学认知的习惯，后缀，前缀表达式由于没有括号和优先级，更符合计算机的处理方式
		- 中缀表达式可[转换为后缀表达式](http://btechsmartclass.com/DS/U2_T5.html) 
		- 中缀表达式语法公式

	```cpp

	<表达式> ::= <项> + <项>
		 	| <项> - <项>
			| <项>
			
	<项> ::= <因子> * <因子>
		 	| <因子> / <因子>
			| <因子>
	<因子> ::= <常数>
			| (<表达式>)
	<常数> ::= <常数>
			| <数字><常数>
	<数字> ::= 0|1|2|3|4|5|6|7|8|9

	```
- 后缀表达式 23 34 45 * 56 + 7 + / +，后缀表达式又称逆波兰表达式，它和中缀表达式的区别是，后缀表达式不需要使用括号




- 后缀表达式求值规则：每次从栈里取两个数字，然后应用运算符


### 队列

- 先进先出
	- 限制访问点的线性表
		- 按照到达的顺序来释放元素
		- 所有的插入在表的一端进行，所有的删除在表的另一端进行

- 主要元素
	- 队头-front
	- 队尾-rear


#### 实现方式

- 顺序队列
	- 使用线性表做存储，空间提前分配好，front和rear做游标
	- 插入时间复杂度为O(1)
	
- 链式队列
	- 用单链表方式存储，队列每个元素对于链表中的一个节点
	- 插入时间复杂度为O(1)

- 环形队列
	- 线性表在部分元素dequeue后会造成空间的浪费，解决这个问题，引入环形队列，它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。
	- 插入时间复杂度为O(1)







### 字符串

- 存储结构
	- 



#### 字符串KMP算法





