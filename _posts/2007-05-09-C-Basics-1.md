---
layout: post
title: C Part1: Makefile
---

## GCC

### GCC编译参数

`.c`编译完成后会生成`.o`文件，多个`.o`文件和一些lib，一起link得到可执行文件，下面是GCC的一些编译选项：

- `gcc`：直接执行`gcc  main.c` 会得到 一个 `a.out`的可执行二进制文件。运行时需要带路径：`./a.out`
-  `-c`: 生成目标文件`.o`。例如得到`main.o`：
- `-o` : 生成可执行文件。例如得到可执行文件p：

```
gcc -o p main.o module1.o module2.o
gcc -o p main.o module1.c module2.c 
```
- `-g`: 编译器在输出文件中包含debug信息，产生dSYM符号表
- `-Wall`:编译器编译时打出warning信息,强烈推荐使用这个选项。
- `-I+dir`: 除了在main.c当前目录和系统默认目录中寻找.h外，还在dir目录寻找，注意，dir是一个绝对路径。

例如：<code> % gcc main.o ./dir/module.o -o p </code>

### Demo

- 文件路径

```
./test/main.c , main.h  ,  module_1.h  ,  module_1.c  
./test/ext/module_2.h  ,  module_2.c
```

- `main` 

```c 
//main.h
 #include <stdio.h>;
int main(void);
//main.m
#include "main.h" 
#include "module_1.h"
#include "module_2.h"

int main(void){

	printf("hello world");
	int ret1 = module_1_Func(100,20); 
	printf("\n%d\n",ret1);
	
    int ret2 = module_2_Func(200,100);
	printf("\n%d\n",ret2);
	return 0;
}
```

- 使用GCC编译
	- 单行名命令
		- `gcc -o output main.c module_1.c ./ext/module_2.c -I./ext`
	- 分步执行，先各自编译成.o，再link
		- <code> % gcc -c module_1.c </code>生成module_1.o
		- <code> % cd ./ext	% gcc -c module_2.c </code>生成module_2.o
		- <code> % gcc -c main.c -I./ext </code>生成main.o
		- <code> % gcc -o p main.o module_1.o ./ext/module_2.o </code>生成p

### NM查看Symbol

- `nm`用来查看目标文件中的符号，命令格式:`nm[-AaefgnoPprsuvx][-t format]`目标文件包括：
	- `.obj`结尾的文件，可能是Object Module Format格式或者是Common Object File Format格式
	- `.lib`结尾文件，包含一个或多个`.obj`文件
	- Windows可执行文件`.exe`
	- 注意，`nm`命令不会列出DLL的entry point，除非有和它关联的符号表。

- 默认情况，`nm`列出按照字母顺序列出符号类型:

```
- A :absolute symbol, global
- a :absolute symbol, local
- B :uninitialized data (bss), global
- b :uninitialized data (bss), local
- D :initialized data, global
- d :initialized data, local
- F :file name
- l :line number entry (see -a option)
- N :no defined type, global; this is an unspecified type, compared to the undefined type U
- n :no defined type, local; this is an unspecified type, compared to the undefined type U
- S :section symbol, global
- s :section symbol, local
- T :text symbol, global
- t :text symbol, local (static)
- U :undefined symbol
- ? :unknown symbol
```

## Makefile

### 简单的Makefile

当一个工程很大，有很多文件时，使用gcc去编译就局限了。这个时候通常使用makefile，makefile中，需要把这些文件组织到一起。
makefile是一个纯文本文件，实际上它就是一个shell脚本(关于Shell脚本可以参考[这里]())，并且对大小写敏感，里面定义一些变量。重要的变量有三个：

- CC ： 编译器名称
	- `% gcc  main.c` 在makefile中的写法为：`$(CC) main.c`
- CFLAGS ： 编译参数，也就是上面提到的gcc的编译选项。
	- `CFLAGS=-Wall -g`
	- 通常用来指定头文件的位置，常用的是`-I, -g`。
- LDFLAGS ：链接参数，告诉链接器lib的位置
	- 常用的有`-I,-L`

```
CC=gcc
CFLAGS=-Wall -g
clean:
	rm -rf main
```

例如，上面的makefile，有以下几点需要说明：

- 缩进必须用`TAB`

main.o: main.c main.h

这句话的意思是main.o必须由main.c，main.h来生成

`$(CC)main.c`

是shell命令，前面必须加tab

针对上面的例子，我们可以写一个makefile 文件


```
C=gcc
CFLAGS=-g -I./ext/

PROG=p
HDRS=main.h module_1.h ./ext/module_2.h
SRCS=main.c module_1.c ./ext/module_2.c

$(PROG):main.h main.c module_1.h ./ext/module_2.h
	$(CC) -o $(PROG) $(SRCS) $(CFLAGS)

```



## Further Reading
- <a href="http://cslibrary.stanford.edu/107/UnixProgrammingTools.pdf">UNIX Programming Tools</a>
- <a href="https://www.mkssoftware.com/docs/man1/nm.1.asp">nm command</a>
