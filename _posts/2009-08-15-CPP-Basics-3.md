---
layout: post
list_title: C++ Part 3 | Copy Control & Operator Overload | 拷贝控制与运算符重载
title: 拷贝控制与运算符重载
categories: [C++]
updated: "2018-02-10"
---

> 持续更新，补充C++新增feature,目录结构遵循《C++ Primer》

## 拷贝控制

C++中可以定义五种函数来控制对象的拷贝，分别是

1. 拷贝构造函数 (copy constructor)
2. 拷贝赋值运算符 (copy-assignment operator)
3. 移动构造函数 (moveconstructor)
4. 移动赋值运算符 move-assignment operator)
5. 析构函数 (destructor)

### 拷贝构造函数

拷贝构造函数是C++类的一个标配，即使不显式定义，编译器也会提供一个默认的合成拷贝构造函数，其定义如下

```cpp
class Foo{
	...
	Foo(const Foo& f); //拷贝构造
	...
};
```

默认拷贝函数的行为是浅拷贝，对象成员通过拷贝构造函数拷贝，如果有数组成员则拷贝数组中的元素。

在C++中，拷贝不仅仅在`=`时发生，下面三种情况均会发生拷贝

1. 对象作为实参传递给非引用类型的形参
2. 返回一个非引用类型的对象
3. 使用`{}`初始化数组中的元素，或者初始化聚合类

```cpp
struct Foo{
	string s;
	int x;
};
Foo f = {"foo",100} //copy
```
值得注意的是，拷贝构造函数可能会被编译器优化为普通构造函数

```cpp
string null_boook = "9-999-9999-99"; //拷贝构造
//编译器优化为普通构造函数
string null_book("9-999-9999-99"); 
```

### 拷贝赋值运算

拷贝赋值运算依赖类重载`=`运算符，如果一个类重载了`=`，相当于为自己添加了一个`operator=`的函数

```cpp
class Foo{
	...
	Foo& operator=(const Foo& f){
		
		//...
		
		return *this;
	}
};
```
如果没有显式定义拷贝赋值运算符，编译器会自动生成一个，其行为和拷贝构造函数一致，如果不想提供拷贝赋值运算，则需要使用`delete`关键字进行显式声明

```cpp
Foo& operator=(const Foo& f) = delete
```
> 如果一个类需要定义赋值拷贝运算符，那么它一定也需要定义拷贝构造函数，反之亦然

### 析构函数

无论何时，一个对象被销毁就会自动调用其析构函数

1. 变量在离开作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（标准库或数组）被销毁时，其元素被销毁
4. 对于动态内存对象，等被delete时，该对象被销毁
5. <mark>对于临时对象，当创建它的完整表达式结束时被销毁</mark>

在C++中，析构函数通常用来释放内存，delete指针，因此，<mark>如果一个类定需要析构函数来释放资源，那么它同样需要定义拷贝构造函数和赋值拷贝运算符来实现对指针的深拷贝</mark>。

### 使用`=default`与`=delete`

如果想要使用默认的拷贝行为，又想显式的声明这些函数，那么可以使用`=default`

```cpp
class Foo{
	Foo() =default;
	Foo(const Foo& f) =default;
	Foo& operator=(const Foo& f);
	~Foo()=default;
};
Foo& Foo::operator=(const Foo& f) =default;
```
如果在类内部声明了`=default`则编译器会将默认实现在类内部展开(内联)，如果不想在类内部展开，则可以在类外部声明`=default`。需要注意的是，`=default`只能用于编译器默认提供的函数，对于一般的成员函数，不能使用。

与`=default`相对的是`=delete`，`=delete`允许类禁用某个函数

```cpp
class Foo{
	Foo() =default;
	Foo(const Foo& f) =delete; //禁止拷贝
	Foo& operator=(const Foo& f); //禁止赋值
	~Foo()=default;
};
```
与`=default`不同的是， `=delete`允许声明除析构函数外的任何函数，这个特点在某些情况下对实现函数重载很有帮助。

### 深拷贝

下面给出一个深拷贝的例子

```cpp
class HasPtr {
public:
	//constructor
 	HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) { }
 
	//copy constructor, deep copy
 	HasPtr(const HasPtr &p): ps(new std::string(*p.ps)), i(p.i) { } 

	 //copy-assign operator, deep copy
	HasPtr& operator=(const HasPtr &){
		auto newp = new string(*rhs.ps); 
 		delete ps; // free the old memory
 		ps = newp; // copy data from rhs into this object
 		i = rhs.i;
 		return *this; // return this object
	} 
	//destructor
	~HasPtr() { delete ps; }
private:
 std::string *ps; int i;
};
```

在上面深拷贝的例子中，需要特别注意一点的是`operator=`中的逻辑，一定是先从待拷贝对象身上new一个新的对象后再delete自己管理的指针。如果先delete掉自己的指针，那么自己给自己赋值时，`this`将会被释放，`*rhs.p`会报错。

> 如果不想自己管理指针的释放，则建议使用`shared_ptr`，`shared_ptr`在被拷贝时会拷贝其所指向的指针（浅拷贝），`shared_ptr`类自己维护指针的引用计数，使我们不需要担心拷贝的问题。

### 移动内存

设想下面这个场景，有一个`vector<string>`类型的数组，每次push一个对象进入后，`vector`内部要check其容量是否已经达到上限，如果已经达到上限，则要进行内存的再分配:

```cpp
void vector<string>::push_back(const string& s){
    chk_n_alloc();
    alloc.construct(first_free++,s);
};
```
其中`chk_n_alloc()`用来做内存检查，其实现如下：

```cpp
if (size() == capacity()){
	reallocate(); //重新分配内存
}
```
这时我们可以思考一下，`reallocate()`函数应该做什么，不难想到，它应该完成以下三个任务

1. 为一个新的，更大的`string`数组分配内存
2. 在内存空间的前一分部拷贝已有的元素进去
3. 销毁原内存空间中的元素，并释放这块内存

观察上述步骤可以看出，其后两步存在一些冗余，即要拷贝原对象到新的内存空间，之后还要释放原对象的内存。这在数组数量大的时候开销是很大的，如果我们可以将原来的对象直接移动到新开辟的内存而不是拷贝，那么后两步则可以省略，效率将可以大大提升。在<mark>C++ 11中引入了两种机制</mark>，分别是移动构造函数和`std::move()`函数。

包括string在内的所有标准库类都定义了所谓的"移动构造函数"，由于实现细节尚未公开，但是我们够确定的有两点，一是移动构造函数将“资源”移动给了目标对象而不是拷贝，二是移动后的string对象仍然是一个有效的，可被析构的对象。

`std::move`定义在`utility`的头文件中，目前关于`move`我们只需要关注两点，一是在`reallocate`函数中我们要用`std::move`函数告诉`string`使用移动构造函数，第二点是在使用`std::move`时，我们通常保留命名空间
    
```cpp
void StrVec::reallocate(){
    auto newsize = size()? size()*2 : 1;
    //alloc new space
    auto newdata = alloc.allocate(newsize);
    auto begin_new = newdata;
    auto begin_old = elements;
    for(int i=0;i<size();++i){
        alloc.construct(begin_new,std::move(*begin_old));
        begin_new++;
        begin_old++;
    }
	free()
    elements = newdata;
    first_free = begin_new;
    cap = elements + newsize;
}
```
上面代码中，我们使用`std::move`将`begin_old`中指向的string对象逐个"移动"到了新的内存区域，随后释放了原先的内存空间，但被移动后string对象内存仍是有效的。

### 右值引用

为了支持移动操作，<mark>C++11引入了右值引用(rvalue reference)</mark>的概念，语法上用`&&`表示，右值引用有一个**重要的性质是它只能绑定到即将销毁的对象上**，因此，我们可以自由的将一个右值资源移动到另一个对象中。

回忆前面的文章可知，等号左右均可使用表达式进行求值，得到的结果分别为左值和右值，其中左值表示一个对象的身份，右值往往是一个**值**，所谓右值引用就是对这个**值的引用**。

对于左值引用，需要绑定的是一个左值，即等号右边是一个左值（变量名），左值引用无法和一个表达式进行绑定，比如

```cpp
int i=42;
int &r = i; //正确，i是左值
int &r = i*2; //错误，等号右边是一个表达式，是一个“值“
```

相反的，右值引用，引用的是一个值，因此它可以绑定到某个表达式上，但却不能和左值绑定

```cpp
int i=42;
int &t = i;
int &&r = i*2; //正确，r绑定到表达式上
int &&r = t; //错误，右值不能绑定到左值上
```

对比左值和右值可发现，左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时变量。由于右值引用只能绑定到临时对象，因此可知

1. 右值所引用的对象将要被销毁
2. 该对象没有其它使用者

这两个特性意味着，使用右值引用的代码可以自由地接管所引用对象的资源

## 运算符重载

- 普通的运算符只能用于基本数据类型
- 对抽象的数据类型也能使用C++提供的数据类型
	- 代码更简洁
	- 代码更容易理解

- 运算符重载的实质是**函数重载**，形式为：

```
返回值类型 operator 运算符（形参表）{}
```

- 在程序编译时：
	- 把运算符的表达式 -> 对运算符函数的调用
	- 把运算符的操作数 -> 运算符函数的参数
	- 运算符多次被重载时，根据实参类型决定调用哪个运算符函数
	
- 运算符可以被重载成**普通函数**
	- 参数个数为运算符的目数（如`+`为二元运算符，因此参数个数为2）
	
	```c++
	class Complex
	{
		public:
			Complex(double r = 0.0, double i = 0.0)
			{
				real = r;
				image = i;
			}		
		double real;
		double image;
	};
	//普通的全局函数
	Complex operator+ (const Complex& a, const Complex& b){
		return Complex(a.real+b.real, a.image+b.image);
	}
	```

- 也可以被重载成类的**成员函数**
	- 参数个数为运算符目数减一 

	```c++
	class Complex
	{
		public:
			Complex(double r = 0.0, double i = 0.0)
			{
				real = r;
				image = i;
			}		
			Complex operator+ (const Complex& );
			Complex operator- (const Complex& );
		private:
			double real;
			double image;
	};
	Complex Complex::operator+(const Complex& op)
	{
		return Complex(real+op.real,image+op.image);
	}
	int main()
	{
		Complex x, y(4.3,2.6), z(3.3,1.1);
		x = y+z; //=> x = y.operator+(z)
		return 0;
	}
	```
	
- 重载`<<`

C++中的`cout<<`使用的也是运算符重载，`cout`是`ostream`类的对象，`ostream`重载了`<<`:

```c++
ostream& ostream::operator<<(int n){
	return *this;
}
//cout<<3<<"this";`等价于:
//cout.operator<<(3).operator<<("this");
```
也可以重载`<<`进行自定义输出

```cpp
class Person{
private:
	string name;

friend ostream& operator<<(ostream& out, const Person& p);
}
ostream& operator<<(ostream& out, const Person& p){
	out<<p.name;
	return out;
}
int main(){
	Person p;
	cout<<p;
}
```

### 赋值运算符重载

- 赋值运算符两边类型可以不匹配
- 赋值运算符`=`只能重载为**成员函数**

```cpp
class string{
	private:
		char* p;
		
	public:
		string():p(NULL){}
		const char* c_str(){ return p; }
		
		char* operator=(const char* s){
			if(p){
				delete[] p;
			}
			if(s){
				int len = strlen(s);
				p = new char[len+1];
				strcpy(p,s);
			}
			else{
				p = NULL;
			}
			return p;
		}
};

int main(){
	string x1 = "abc"; //通过重载运算符实现
}

```

- 深浅拷贝
	- 发生在两个对象互相赋值的过程中 
	- 浅拷贝的问题:如果成员变量有指针对象，那么浅拷贝会导致被复制的对象和原对象的指针成员变量值相同，即他们指向同一块内存区域，当对象析构时，会有double free的风险 

```cpp
string& operator=(string& s){

	if(s.c_str() == p){ //自己赋值给自己
		return *this;
	}

	if(p){
		delete[] p;
	}
	p = new char[strlen(s.c_str()+1)];
	strcpy(p,s.c_str());
	return *this;
}


int main(){
	string x1="abc";
	string x2;
	x2 = x1; //通过重载运算符实现
}	
```

- 返回值不能设计成void，会有`a=b=c`的情况
	- 等价于`a.operator=(b.operator=(c))` 
- 返回值要设计成引用类型
	- 运算结果最终还是作用于自身，因此返回值用引用 

### 运算符重载为友元函数

- 成员函数不能满足使用要求
- 普通函数，又不能访问类的私有成员


### 自加/自减运算符重载

- 自加`++`, 自减`--`运算符有前置/后置之分
- **前置**运算符为一元运算符重载, 返回左值
	- 重载为成员函数

	```cpp
	//重载为成员函数
	T operator++();
	T operator--();
	```
	- 重载为全局函数
	​	
	``cpp
	//重载为全局函数:
	T operator++(T);
	T operator--(T);
	```
	- `++obj, obj.operator++(), operator++(obj)`都调用上述函数

- **后置**运算符作为二元运算符重载
	- 多写一个参数，具体无意义，返回右值
	- 重载为成员函数
	
	```cpp
	T operator++(int); //多写一个参数告诉编译器是后置运算，初始化为0
	T operator--(int);
	```
	- 重载为全局函数	

	```cpp
	T operator++(T, int);
	T operator--(T, int); //第二个参数没有特殊意义, 默认初始化为0
	```
	- `obj++, obj.operator++(0), operator++(obj, 0)` 都调用上述函数

- `CDemo`例子

```cpp
class CDemo {
private :
	int n;
public:
	CDemo(int i=0):n(i) { }
	CDemo & operator++(); //用于前置++形式
	CDemo operator++(int); //用于后置++形式
	operator int ( ) { 
		return n; 
	}
	friend CDemo & operator--(CDemo &); //友元全局函数，用于前置--形式
	friend CDemo operator--(CDemo &, int); //友元全局函数，用于后置--形式
};
CDemo & CDemo::operator++() { //前置 ++
	n++;
	return * this;
}
CDemo CDemo::operator++(int k) { //后置 ++
	CDemo tmp(*this); //记录修改前的对象
	n++;
	return tmp; //返回修改前的对象
}
CDemo & operator--(CDemo & d) { //前置--
	d.n--;
	return d;
}
CDemo operator--(CDemo & d, int) { //后置--
	CDemo tmp(d);
	d.n -;
	return tmp;
} 

int main(){
	CDemo d(5);
	cout << (d++) << ","; //等价于 d.operator++(0);
	cout << d << ",";
	cout << (++d) << ","; //等价于 d.operator++();
	cout << d << endl;
	cout << (d--) << ","; //等价于 operator--(d,0);
	cout << d << ",";
	cout << (--d) << ","; //等价于 operator--(d);
	cout << d << endl;
	return 0;
} 
```


### 类型强制转换运算符重载	

- 有时需要对某个对象进行强制类型转换，转换规则也可以重载，例如:

```cpp
operator int(){return n;}
```

> `int`作为一个类型强制转换运算符被重载，`Demo s; (int)s`，等价于`s.int()`

- 类型强制装换运算符重载时
	- 不能写返回值类型
	- 实际上其返回值类型为强制转换后的类型

```cpp
class Number
{
  public:
    int num;
    Number(int n = 0) : num(n) {}
    int operator*(const Number &n){
        return num * n.num;
    }
    operator int(){
        return num;
   }
}; 

int main()
{
    Number n1(10), n2(20);
    Number n3;
    n3 = n1 * n2;
    cout << int(n3) << endl; //类型转换
    return 0;
}
```

### 函数对象(functor)

- 定义：若一个类重载运算符`()`，则该类对象就称为函数对象
- 头文件：`<functional>`

```cpp
class A{
public:
	double operator()(int a1, int a2, int a3){
		return (double)(a1+a2+a3)/3;
	}
};
A average; //函数对象
cout<<average(2,3,4); //averate.operator()(3,2,4)
```
- STL中的函数对象模板
	- `equal_to`
	- `greater`
	- `less`
- `greater`函数对象模板:

```cpp
template<class T>
struct greater:public binary_function<T,T,bool>{
	bool operator()(const T& x, const T& y)const{
		return x>y;
	}
}
```

### 运算符重载的注意事项

- C++不允许定义新的运算符
- 以下运算符不能被重载
	- `.` , `.*`, `::`,`?:`,`sizeof`
-	重载运算符`()`, `[ ]`, `->`或者赋值运算符`=`时, 重载函数必须声明为类的成员函数


