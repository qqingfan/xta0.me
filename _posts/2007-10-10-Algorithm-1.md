---
layout: post
title: Algorithm Part 1
---

## 算法的特性及分类

### 算法特性

- 通用性
	- 对参数化输入进行问题求解
	- 保证计算结果的正确性

- 有效性
	- 算法是有限条指令组成的指令序列
	- 即由一系列具体步骤组成  

- 确定性
	- 算法描述中的下一步应该执行的步骤必须明确

- 有穷性
	- 算法的执行必须在有限步内结束
	- 换句话说，算法不能含有死循环 

### 算法分类

- 穷举法
	- 顺序查找k值

- 回溯，搜索
	- 八皇后，树和图的遍历

- 递归分治
	- 二分法找k值，快速排序，归并排序

- 贪心法
	- Huffman编码树，最短路径Dijkstra，最小生成树prim算法

- 动态规划
	- 最短路Floyd算法      

	
## 算法度量

- 算法渐进分析

```
f(n) = n^2 + 100n + log10(n) + 1000
```
- 当数据规模n逐步增大时，f(n)的增长趋势
- 当n增大到一定值后，计算公式中影响最大的就是n的幂次最高的项
 - 其它的常数项和低幂次项都可以忽略

- <mark>大O表示法</mark>
	- 函数`f`，`g`定义域为自然数，值域为非负实数集
	- 定义：如果存在正数`c`和`n0`，使得任意`n>=n0`，都有`f(n)< cg(n)`
		- 称f(n)在O(g(n))的集合中，简称f(n)是O(g(n))的，或者f(n) = O(g(n))
		- 大O表示法：表达函数增长率的上限
			- 一个函数增长率的上限可能不止一个，尽量找到最紧的
		- 当上下限相同时可以用θ表示法 

- 大O表示法的单位时间 
	- 简单的布尔或算术运算:`O(1)`
	- 简单I/O
		- 函数的输入/输出
			- 例如，从数组读取数据等操作 
		- 不包括文件的I/O
	- 函数的返回

- 大O表示法的运算法则
	- 加法规则: `f1(n) + f2(n) = O(max(f1(n),f2(n)))`
		- 顺序结构，if结构，switch结构
	
	- 乘法规则: `f1(n) * f2(n) = O(f1(n) * f2(n))`
		- `for，while，do-while结构`

		```c		
		for(int i=0; j<n; i++){
			for(j=i;j<n;j++)
			{ k++; }
		}
		//复杂度为O(n^2)
		```

- 大Ω表示法
	- 定义：如果存在正数c和n0，使得对所有n>=n0，都有**f(n) >= cg(n)**，则称f(n)在集合Ω(g(n))中，或简称f(n)是Ω(g(n))的，或f(n) =  Ω(g(n))。主要用于确认算法时间复杂度的下界
	- 与大O表示法唯一的区别在于不等式的方向而已


- 大θ表示法
	- 当上，下限相同时则可以用theta表示法 
	- 定义：如果一个函数在集合O(g(n))中又在集合 Ω(g(n))中，则称其为theta(g(n))
		- 也即，当上下限相同时可以用大θ表示法
		- 存在常数c1,c2，以及整数n0，使得对任意的正整数n>n0，有下列不等式成立：c1g(n)<= f(n) <= c2g(n)  



- 增长率函数曲线

<math>
    <msubsup><mi>2</mi> <mi></mi> <mi>n</mi></msubsup>
    <mo>></mo>
    <msubsup><mi>n</mi> <mi></mi> <mi>2</mi></msubsup>
    <mo>></mo>
	<msubsup><mi>nlog</mi> <mi>2</mi> <mi>n</mi></msubsup> 
	 <mo>></mo>
	 <msubsup><mi>n</mi> <mi></mi> <mi></mi></msubsup>
	 <mo>></mo>
	 <msubsup><mi>log</mi> <mi>2</mi> <mi>n</mi></msubsup>     
</math>



- 问题空间 vs 时间开销，衡量一个算法要考虑数据集最好，最坏以及平均三种情况的时间复杂度
	- 顺序找K值：顺序从一个规模为n的一维数组中找出一个给定的k值
		- 最佳情况:数组中第一个元素就是k，那么只要检测一个元素，复杂度为O(1)
		- 最坏情况:k是数组中最后一个元素，那么需要遍历所有元素，复杂度为O(n)
		- 平均情况:k值出现在n个位置上的概率都是1/n，平均代价O(n) = (1+2+3+..+n)/n = (n+1)/2 
	- 二分法找k值，对于已排序的线性表 
	
- 时间/空间权衡
	- 数据结构
		- 一定的控件来存储它的每一个数据项
		- 一定的时间来执行单个基本操作
	
	- 代价和效益
		- 空间和时间的限制
		- 软件工程

	- 增大空间开销可能改善算法的时间开销
	- 节省空间，会带来时间的增大   	  

	