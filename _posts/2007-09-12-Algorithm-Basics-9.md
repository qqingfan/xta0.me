---
layout: post
list_title: Algorithms-9 | 动态规划 | Dynamic Programming
mathjax: true
---

## 动态规划(Dynamic Programming)

### 斐波那契数列

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。子问题和原问题是同一类问题，子问题解决的颗粒度更小，最后将子问题的解合并得到原问题的解。
动态规划往往比递归更高效，因为递归中有大部分的重复计算，以斐波那契数列为例，递归解法为:

```python
def fib1(n):
    if n==0 or n==1:
        return n
    else:
        return fib1(n-1)+fib1(n-2)
```
当 `n=5`时，`fib(5)`的递归计算过程如下:

```
fib(5)
fib(4) + fib(3)
(fib(3) + fib(2)) + (fib(2) + fib(1))
((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
```
这种算法对于相似的子问题（求解`fib(3),fib(2),fib(1),fib(0)`）进行了重复的计算，因此不是一种高效的算法，主要有两方面问题：

1. 存在大量的重复计算
2. 算法的运算时间是指数级增长的，递归很深的情况下（比如n>60），性能显著下降

我们来分析一下使用递归解法的时间复杂度，在计算它的时间复杂度之前，我们先看看斐波那契数列的递推式$f_n = f_{n-1} + f_{n-2}$，其中$f_0=1, f_1 = 1$。可以对该数列求和得到$f_n=\frac{1}{\sqrt 5}(\frac{1+\sqrt 5}{2})^{n+1} - \frac{1}{\sqrt 5}(\frac{1- \sqrt 5}{2})^{n+1}$，显然这是一个指数函数。

接下来我们分析上述算法的时间复杂度，不难得出，时间复杂度的递推式为：$T(n) = T(n-1) + T(n-2) + 1, n>1$，经过推导可以得出它正比于Fibonacci的递推式，即

$$T(n) = 2 * fib(n+1)-1 = O(fib(n+1)) = O(\Phi^n) = O(2^n)$$

<img src="/assets/images/2015/02/fib.png" width="70%"/>

显然它的时间复杂度递推式也是只呈指数级增长的，我们可以初步推算下它有多耗时

- 改进斐波那契算法

上面的递归方法，可以看到一个比较大的问题是存在大量的重复递归运算，因此一个很直观的思路是对中间计算的结果进行缓存（memoization），但整个计算过程还是递归向下的。而另一个思路就是使用动态规划，颠倒计算方向，由自定而下的递归改为自底向上的迭代。

```python
def fib(n):
    while(n > 0):
        f = 0  //fib(0)
        g = 1  //fib(1)
        g = f+g
        f = g-f
        n = n-1
    return g
```

改为迭代算法后，时间复杂度降为$O(n)$，空间复杂度仅为$O(1)$。如果上面迭代算法有些不好理解的话，下面这个迭代版本则理解起来更为容易，但是需要$O(n)$的空间复杂度。

```python
def fib2(n):
    l = list(range(0,n+1)) #缓存计算好的结果
    #确定初始状态
    l[0] = 0 
    l[1] = 1 
    #循环递推代替多层递归
    for i in range(2,n+1):
        l[i] = l[i-1]+l[i-2]

    return l[n]
```

对于递归问题，我们可以用以下方法，将其转化为动归问题：

1. 递归函数有n个参数，就定义一个n为数组
2. 数组的下标是递归函数参数的取值范围
3. 数组的元素值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程

因此，从某种意义上讲，<mark>所谓的动态规划，也可以理解为使用递归找出算法的本质，并给出一个初步的解之后，再将其等效的转化为迭代的形式</mark>

### 最长上升子序列youtu

求解上升子序列是动态规划中比较经典的NP问题，问题如下：

> 一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).你的任务，就是对于给定的序列，求出最长上升子序列的长度。

- 将原问题拆解成若干个子问题

将求解`F(n)`最大子序列长度的问题分解为求以`a[k](k=1, 2, 3...N`)为终点的最长上升子序列的长度，即求`F(1)`,`F(2)`,`F(3)`...`F(n)`的最大子序列长度，再从中选取一个最大值

- 确定状态

每个子问题只和一个状态有关，即数字的位置`k`，而状态`k`对应的值为以`ak`做为终点的最长上升子序列的长度。状态个数为`N`

- 确定状态转移方程

假设对于第`k`个位置的最长子序列值为`maxLen(k)`, 要找到它和前面值的递推关系，则有:

```
maxLen(1) = 1
maxLen(k) = max{ maxLen(i) | 1<=i<k and ai < ak and k != 1 } + 1
```
`maxLen(k)`的值，就是在`ak`左边，“终点”数值小于`ak` ，且长度最大的那个上升子序列的长度再加`1`。因为`ak`左边任何“终点”小于`ak`的子序列，加上`ak`后就能形成一个更长的上升子序列。

```c
int a[n];
int maxLen[n];
for(int i=2; i<n; i++){
    for(int j=1; j<i; j++){
        if(a[i]>a[j]){
            maxLen[i] = max(maxLeb[i],maxLen[j]+1)
        }
    }
}
```

### 动态规划解题的一般步骤

1. 将原问题分解为子问题
    - 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题解决，原问题即解决
    - 子问题的解<mark>可以缓存</mark>，所以每个子问题只需要求解一次

2. 确定状态
    - 将和子问题相关的各个变量的一组取值，称之为一个`状态`，一个`状态`对应于一个或多个子问题，所谓某个`状态`下的`值`，就是这个状态所对应的子问题的`解`
    - 所有`状态`的集合，构成问题的`状态空间`。状态空间的大小解解决问题的时间复杂度直接相关。整个问题的时间复杂度是<mark>状态数目乘以每个状态所需要的时间</mark>
    - 经常碰到的情况是，K个整型变量能够成一个状态。如果这个K个整型变量的取值范围分别是`N1,N2,...,Nk`，那么，我们就可以用一个K维数组`array[N1][N2]...[Nk]`来存储各个状态的`值`。这个`值`未必是一个整数或浮点数，也可以是一个复杂的数据结构
3. 确定一些初始状态（边界状态）的值
4. 确定状态转移方程
    - 找到不同状态之间如何迁移-即如何从一个或多个值已知的状态，求出另一个状态的值。状态的迁移可以用递推公式表示，递推公式也可被称作<mark>状态转移方程</mark>
        - 递推公式可以从前往后推导，也可以从后向前推导 
    - 当选取的状态，难以进行递推时（分解出的子问题和原问题形式不一样，或不具有无后效性），考虑将状态<mark>增加限制条件后分类细化，即增加维度</mark>，然后在新的状态上尝试递推

### 能用动规解决问题的特点

1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质
2. <mark>无后效性</mark>。当前的若干状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前的状态无关




