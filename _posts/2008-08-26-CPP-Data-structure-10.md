---
layout: post
list_title: Data Structre Part 9 | Searching Part 1 - Hashing | 搜索-散列
title: 搜索(一)：散列 | Hashing
# sub_title: Searching
mathjax: true
---

## 搜索概述

检索是指在一组记录集合中根据key来寻找value的过程。对于搜索来说，最关键的是搜索效率，尤其是对于大数据量，需要对待检索数据进行**特殊的存储处理**（比如搜索引擎有上千万的query，对应后端有几十亿的网页）来保证检索时间。为了提高搜索效率，常用的方法有：

1. 预排序

    排序算法本身比较耗时，无法实时来进行，因此排序只能作为预处理手段，在检索之前完成

2. 建索引

    如果对某种数据需要反复查找，则需要建立比较高效的索引，检索时充分利用辅助索引信息。代价是牺牲一定的空间，以空间换时间。同时维护成本也有所提高，当数据变化时，索引也要改变

3. 散列

   所谓散列就是把数据组织到一个表中，将Query通过某种算法(hash)得出它的value在表中的位置，从而完成检索。这种方式的优点是查询时间为`O(1)`，缺点是不适合进行范围查询，一般也不允许出现重复的关键码。另外，散列也不适合对磁盘文件进行检索（可以选择 B 树方法）。

### 平均检索长度

检索运算的主要操作为关键码的比较，所谓**平均检索长度(Average Search Length)**是指<mark>检索过程中对关键码的平均比较次数</mark>，它是衡量检索算法优劣的时间标准。

$$
ASL = \sum_{i=1}^{n} P_iC_i 
$$

其中, $P_i$为检索第i个元素的概率，$C_i$为找到第i个元素所需的关键码值与给定值的比较次数

### 顺序检索

我们以顺序检索为例，看下平均检索长度是如何定义以及计算的。所谓线性表检索，其方法就是检索针对线性表里的所有记录，逐个进行关键码和给定值的比较，若某个记录的关键码和给定值比较相等，则检索成功，否则检索失败。

顺序检索可以用用于向量和列表，对数组是否有序没有要求。由于遍历算法相对简单，这里不做赘述，给出其性能分析

1. 检索成功/失败

    假设每个关键码等概率出现: $P_i=1/n$，从后向前遍历，如果最后一个数字恰好为关键码，则只需比较一次，如果关键码在第一个数字的位置，则需要比较$n-1$次，因此检索成功的概率为$p$，检索失败的概率为${1-p}$：

    $$
    p = \sum_{i=0}^{n-1} P_i * (n-i) = \frac{1}{n}\sum_{i=0}^{n-1}(n-i) = \sum_{i=1}^{n}i = \frac{n+1}{2}
    $$

2. 平均检索长度
    将$p$,$q$带入公式可得到 $(n+1)/2 < ASL < (n+1)$

    $$
    ASL = p* \frac{n+1}{2} + q*(n+1) = (n+1)(1-p/2)
    $$


显然顺序检索的时间复杂度在$\Theta(n)$量级，时间略长，优化方式可采用给数组排序后，进行二分检索。对于二分检索和其性能分析可参考[之前文章]()。二分检索过程可用一颗BST来表示，其中每个parent节点的值为数组每次二分mid位置对应的值：

<img src="/assets/images/2007/09/BS.png" width="40%" style="margin-left:auto; margin-right:auto;display:block">

观察这棵树可发现，其最大的检索位置为叶节点`22`的位置，推而广之，可知二分法最大检索长度为$\lfloor \log{n+1} \rfloor$。其失败的检索位置有`15,51,22,93`因此，最大失败检索长度也为$\lfloor \log{n+1} \rfloor$。则其平均检索长度为：

$$
ASL = \frac{1}{n} * (\sum_{i=1}^{j}i*2^{(i-1)}) = \frac{n+1}{n}\log{(n+1)}-1 \approx \log{(n+1) -1} \qquad (n>50)
$$

## 散列

通过上面线性表的检索可以看出，检索的过程是通过元素之间的比较来完成的，而基于比较的运算为无论怎么优化时间代价都是很高的(因为无论怎样都和`n`）相关，当`n`很大时，如果是实时搜索的场景，上述检索时间效率基本是无法接受的。那么一个比较理想的情况是怎样呢？我们希望

1. 根据关键码值，直接找到记录的存储地址
2. 不需要把待查关键码与候选记录集合的某些记录进行逐个比较

具有上述特征的数据结构在前面介绍向量时曾接触过，就是`vector`，`vector`可以通过下标访问可直接找到数据在内存中的位置，其原因是`vector`在内存是连续存储的，下标访问实际上是指针运算，因此可以快速寻址。

散列也是类似的概念，通过对某个key的某种运算("哈希")得到一个该key指向数据的地址，根据该地址直接访问数据。因此使用散列搜索需要：

1. 有一个散列函数`h`,以结点的关键码`K`为自变量,函数值`h(K)`作为结点的存储地址
2. 需要一个存储空间，通常是一个一维数组，散列地址是数组的下标


    



